/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8
                <= self.storage.as_ref().len()
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8
                <= self.storage.as_ref().len()
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 9;
pub const __GLIBCXX__: u32 = 20200130;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EBADMSG: u32 = 1;
pub const _GLIBCXX_HAVE_ECANCELED: u32 = 1;
pub const _GLIBCXX_HAVE_ECHILD: u32 = 1;
pub const _GLIBCXX_HAVE_EIDRM: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENODATA: u32 = 1;
pub const _GLIBCXX_HAVE_ENOLINK: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSPC: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSTR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTRECOVERABLE: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTSUP: u32 = 1;
pub const _GLIBCXX_HAVE_EOVERFLOW: u32 = 1;
pub const _GLIBCXX_HAVE_EOWNERDEAD: u32 = 1;
pub const _GLIBCXX_HAVE_EPERM: u32 = 1;
pub const _GLIBCXX_HAVE_EPROTO: u32 = 1;
pub const _GLIBCXX_HAVE_ETIME: u32 = 1;
pub const _GLIBCXX_HAVE_ETIMEDOUT: u32 = 1;
pub const _GLIBCXX_HAVE_ETXTBSY: u32 = 1;
pub const _GLIBCXX_HAVE_EWOULDBLOCK: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &'static [u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &'static [u8; 30usize] =
    b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &'static [u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &'static [u8; 15usize] =
    b"version-unused\0";
pub const STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INT128: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const CINDEX_VERSION_MAJOR: u32 = 0;
pub const CINDEX_VERSION_MINOR: u32 = 59;
pub type std_size_t = ::std::os::raw::c_ulong;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timex {
    pub modes: ::std::os::raw::c_uint,
    pub offset: __syscall_slong_t,
    pub freq: __syscall_slong_t,
    pub maxerror: __syscall_slong_t,
    pub esterror: __syscall_slong_t,
    pub status: ::std::os::raw::c_int,
    pub constant: __syscall_slong_t,
    pub precision: __syscall_slong_t,
    pub tolerance: __syscall_slong_t,
    pub time: timeval,
    pub tick: __syscall_slong_t,
    pub ppsfreq: __syscall_slong_t,
    pub jitter: __syscall_slong_t,
    pub shift: ::std::os::raw::c_int,
    pub stabil: __syscall_slong_t,
    pub jitcnt: __syscall_slong_t,
    pub calcnt: __syscall_slong_t,
    pub errcnt: __syscall_slong_t,
    pub stbcnt: __syscall_slong_t,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize], u8>,
}
#[test]
fn bindgen_test_layout_timex() {
    assert_eq!(
        ::std::mem::size_of::<timex>(),
        208usize,
        concat!("Size of: ", stringify!(timex))
    );
    assert_eq!(
        ::std::mem::align_of::<timex>(),
        8usize,
        concat!("Alignment of ", stringify!(timex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timex>())).modes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timex>())).freq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).maxerror as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).esterror as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).status as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).constant as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).precision as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).tolerance as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timex>())).time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timex>())).tick as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).ppsfreq as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).jitter as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timex>())).shift as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).stabil as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).jitcnt as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).calcnt as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).errcnt as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timex>())).stbcnt as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timex>())).tai as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tai)
        )
    );
}
extern "C" {
    pub fn clock_adjtime(
        __clock_id: __clockid_t,
        __utx: *mut timex,
    ) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__names as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strptime_l(
        __s: *const ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(
        __clock_id: clockid_t,
        __res: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(
        __clock_id: clockid_t,
        __tp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(
        __clock_id: clockid_t,
        __tp: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(
        __pid: pid_t,
        __clock_id: *mut clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(
        __timerid: timer_t,
        __value: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdate(__string: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn getdate_r(
        __string: *const ::std::os::raw::c_char,
        __resbufp: *mut tm,
    ) -> ::std::os::raw::c_int;
}
pub mod CXErrorCode {
    pub type Type = u32;
    pub const CXError_Success: Type = 0;
    pub const CXError_Failure: Type = 1;
    pub const CXError_Crashed: Type = 2;
    pub const CXError_InvalidArguments: Type = 3;
    pub const CXError_ASTReadError: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXString {
    pub data: *const ::std::os::raw::c_void,
    pub private_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXString() {
    assert_eq!(
        ::std::mem::size_of::<CXString>(),
        16usize,
        concat!("Size of: ", stringify!(CXString))
    );
    assert_eq!(
        ::std::mem::align_of::<CXString>(),
        8usize,
        concat!("Alignment of ", stringify!(CXString))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXString>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXString),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXString>())).private_flags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXString),
            "::",
            stringify!(private_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXStringSet {
    pub Strings: *mut CXString,
    pub Count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXStringSet() {
    assert_eq!(
        ::std::mem::size_of::<CXStringSet>(),
        16usize,
        concat!("Size of: ", stringify!(CXStringSet))
    );
    assert_eq!(
        ::std::mem::align_of::<CXStringSet>(),
        8usize,
        concat!("Alignment of ", stringify!(CXStringSet))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXStringSet>())).Strings as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXStringSet),
            "::",
            stringify!(Strings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXStringSet>())).Count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXStringSet),
            "::",
            stringify!(Count)
        )
    );
}
extern "C" {
    pub fn clang_getCString(string: CXString) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn clang_disposeString(string: CXString);
}
extern "C" {
    pub fn clang_disposeStringSet(set: *mut CXStringSet);
}
extern "C" {
    pub fn clang_getBuildSessionTimestamp() -> ::std::os::raw::c_ulonglong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXVirtualFileOverlayImpl {
    _unused: [u8; 0],
}
pub type CXVirtualFileOverlay = *mut CXVirtualFileOverlayImpl;
extern "C" {
    pub fn clang_VirtualFileOverlay_create(
        options: ::std::os::raw::c_uint,
    ) -> CXVirtualFileOverlay;
}
extern "C" {
    pub fn clang_VirtualFileOverlay_addFileMapping(
        arg1: CXVirtualFileOverlay,
        virtualPath: *const ::std::os::raw::c_char,
        realPath: *const ::std::os::raw::c_char,
    ) -> CXErrorCode::Type;
}
extern "C" {
    pub fn clang_VirtualFileOverlay_setCaseSensitivity(
        arg1: CXVirtualFileOverlay,
        caseSensitive: ::std::os::raw::c_int,
    ) -> CXErrorCode::Type;
}
extern "C" {
    pub fn clang_VirtualFileOverlay_writeToBuffer(
        arg1: CXVirtualFileOverlay,
        options: ::std::os::raw::c_uint,
        out_buffer_ptr: *mut *mut ::std::os::raw::c_char,
        out_buffer_size: *mut ::std::os::raw::c_uint,
    ) -> CXErrorCode::Type;
}
extern "C" {
    pub fn clang_free(buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn clang_VirtualFileOverlay_dispose(arg1: CXVirtualFileOverlay);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXModuleMapDescriptorImpl {
    _unused: [u8; 0],
}
pub type CXModuleMapDescriptor = *mut CXModuleMapDescriptorImpl;
extern "C" {
    pub fn clang_ModuleMapDescriptor_create(
        options: ::std::os::raw::c_uint,
    ) -> CXModuleMapDescriptor;
}
extern "C" {
    pub fn clang_ModuleMapDescriptor_setFrameworkModuleName(
        arg1: CXModuleMapDescriptor,
        name: *const ::std::os::raw::c_char,
    ) -> CXErrorCode::Type;
}
extern "C" {
    pub fn clang_ModuleMapDescriptor_setUmbrellaHeader(
        arg1: CXModuleMapDescriptor,
        name: *const ::std::os::raw::c_char,
    ) -> CXErrorCode::Type;
}
extern "C" {
    pub fn clang_ModuleMapDescriptor_writeToBuffer(
        arg1: CXModuleMapDescriptor,
        options: ::std::os::raw::c_uint,
        out_buffer_ptr: *mut *mut ::std::os::raw::c_char,
        out_buffer_size: *mut ::std::os::raw::c_uint,
    ) -> CXErrorCode::Type;
}
extern "C" {
    pub fn clang_ModuleMapDescriptor_dispose(arg1: CXModuleMapDescriptor);
}
pub type CXIndex = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXTargetInfoImpl {
    _unused: [u8; 0],
}
pub type CXTargetInfo = *mut CXTargetInfoImpl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXTranslationUnitImpl {
    _unused: [u8; 0],
}
pub type CXTranslationUnit = *mut CXTranslationUnitImpl;
pub type CXClientData = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXUnsavedFile {
    pub Filename: *const ::std::os::raw::c_char,
    pub Contents: *const ::std::os::raw::c_char,
    pub Length: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_CXUnsavedFile() {
    assert_eq!(
        ::std::mem::size_of::<CXUnsavedFile>(),
        24usize,
        concat!("Size of: ", stringify!(CXUnsavedFile))
    );
    assert_eq!(
        ::std::mem::align_of::<CXUnsavedFile>(),
        8usize,
        concat!("Alignment of ", stringify!(CXUnsavedFile))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXUnsavedFile>())).Filename as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXUnsavedFile),
            "::",
            stringify!(Filename)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXUnsavedFile>())).Contents as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXUnsavedFile),
            "::",
            stringify!(Contents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXUnsavedFile>())).Length as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXUnsavedFile),
            "::",
            stringify!(Length)
        )
    );
}
pub mod CXAvailabilityKind {
    pub type Type = u32;
    pub const CXAvailability_Available: Type = 0;
    pub const CXAvailability_Deprecated: Type = 1;
    pub const CXAvailability_NotAvailable: Type = 2;
    pub const CXAvailability_NotAccessible: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXVersion {
    pub Major: ::std::os::raw::c_int,
    pub Minor: ::std::os::raw::c_int,
    pub Subminor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CXVersion() {
    assert_eq!(
        ::std::mem::size_of::<CXVersion>(),
        12usize,
        concat!("Size of: ", stringify!(CXVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<CXVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(CXVersion))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXVersion>())).Major as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXVersion),
            "::",
            stringify!(Major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXVersion>())).Minor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CXVersion),
            "::",
            stringify!(Minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXVersion>())).Subminor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXVersion),
            "::",
            stringify!(Subminor)
        )
    );
}
pub mod CXCursor_ExceptionSpecificationKind {
    pub type Type = u32;
    pub const CXCursor_ExceptionSpecificationKind_None: Type = 0;
    pub const CXCursor_ExceptionSpecificationKind_DynamicNone: Type = 1;
    pub const CXCursor_ExceptionSpecificationKind_Dynamic: Type = 2;
    pub const CXCursor_ExceptionSpecificationKind_MSAny: Type = 3;
    pub const CXCursor_ExceptionSpecificationKind_BasicNoexcept: Type = 4;
    pub const CXCursor_ExceptionSpecificationKind_ComputedNoexcept: Type = 5;
    pub const CXCursor_ExceptionSpecificationKind_Unevaluated: Type = 6;
    pub const CXCursor_ExceptionSpecificationKind_Uninstantiated: Type = 7;
    pub const CXCursor_ExceptionSpecificationKind_Unparsed: Type = 8;
    pub const CXCursor_ExceptionSpecificationKind_NoThrow: Type = 9;
}
extern "C" {
    pub fn clang_createIndex(
        excludeDeclarationsFromPCH: ::std::os::raw::c_int,
        displayDiagnostics: ::std::os::raw::c_int,
    ) -> CXIndex;
}
extern "C" {
    pub fn clang_disposeIndex(index: CXIndex);
}
pub mod CXGlobalOptFlags {
    pub type Type = u32;
    pub const CXGlobalOpt_None: Type = 0;
    pub const CXGlobalOpt_ThreadBackgroundPriorityForIndexing: Type = 1;
    pub const CXGlobalOpt_ThreadBackgroundPriorityForEditing: Type = 2;
    pub const CXGlobalOpt_ThreadBackgroundPriorityForAll: Type = 3;
}
extern "C" {
    pub fn clang_CXIndex_setGlobalOptions(
        arg1: CXIndex,
        options: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_CXIndex_getGlobalOptions(
        arg1: CXIndex,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXIndex_setInvocationEmissionPathOption(
        arg1: CXIndex,
        Path: *const ::std::os::raw::c_char,
    );
}
pub type CXFile = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn clang_getFileName(SFile: CXFile) -> CXString;
}
extern "C" {
    pub fn clang_getFileTime(SFile: CXFile) -> time_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXFileUniqueID {
    pub data: [::std::os::raw::c_ulonglong; 3usize],
}
#[test]
fn bindgen_test_layout_CXFileUniqueID() {
    assert_eq!(
        ::std::mem::size_of::<CXFileUniqueID>(),
        24usize,
        concat!("Size of: ", stringify!(CXFileUniqueID))
    );
    assert_eq!(
        ::std::mem::align_of::<CXFileUniqueID>(),
        8usize,
        concat!("Alignment of ", stringify!(CXFileUniqueID))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXFileUniqueID>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXFileUniqueID),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn clang_getFileUniqueID(
        file: CXFile,
        outID: *mut CXFileUniqueID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_isFileMultipleIncludeGuarded(
        tu: CXTranslationUnit,
        file: CXFile,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getFile(
        tu: CXTranslationUnit,
        file_name: *const ::std::os::raw::c_char,
    ) -> CXFile;
}
extern "C" {
    pub fn clang_getFileContents(
        tu: CXTranslationUnit,
        file: CXFile,
        size: *mut size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn clang_File_isEqual(
        file1: CXFile,
        file2: CXFile,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_File_tryGetRealPathName(file: CXFile) -> CXString;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXSourceLocation {
    pub ptr_data: [*const ::std::os::raw::c_void; 2usize],
    pub int_data: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXSourceLocation() {
    assert_eq!(
        ::std::mem::size_of::<CXSourceLocation>(),
        24usize,
        concat!("Size of: ", stringify!(CXSourceLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<CXSourceLocation>(),
        8usize,
        concat!("Alignment of ", stringify!(CXSourceLocation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXSourceLocation>())).ptr_data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXSourceLocation),
            "::",
            stringify!(ptr_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXSourceLocation>())).int_data as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXSourceLocation),
            "::",
            stringify!(int_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXSourceRange {
    pub ptr_data: [*const ::std::os::raw::c_void; 2usize],
    pub begin_int_data: ::std::os::raw::c_uint,
    pub end_int_data: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXSourceRange() {
    assert_eq!(
        ::std::mem::size_of::<CXSourceRange>(),
        24usize,
        concat!("Size of: ", stringify!(CXSourceRange))
    );
    assert_eq!(
        ::std::mem::align_of::<CXSourceRange>(),
        8usize,
        concat!("Alignment of ", stringify!(CXSourceRange))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXSourceRange>())).ptr_data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXSourceRange),
            "::",
            stringify!(ptr_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXSourceRange>())).begin_int_data as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXSourceRange),
            "::",
            stringify!(begin_int_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXSourceRange>())).end_int_data as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CXSourceRange),
            "::",
            stringify!(end_int_data)
        )
    );
}
extern "C" {
    pub fn clang_getNullLocation() -> CXSourceLocation;
}
extern "C" {
    pub fn clang_equalLocations(
        loc1: CXSourceLocation,
        loc2: CXSourceLocation,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getLocation(
        tu: CXTranslationUnit,
        file: CXFile,
        line: ::std::os::raw::c_uint,
        column: ::std::os::raw::c_uint,
    ) -> CXSourceLocation;
}
extern "C" {
    pub fn clang_getLocationForOffset(
        tu: CXTranslationUnit,
        file: CXFile,
        offset: ::std::os::raw::c_uint,
    ) -> CXSourceLocation;
}
extern "C" {
    pub fn clang_Location_isInSystemHeader(
        location: CXSourceLocation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_Location_isFromMainFile(
        location: CXSourceLocation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_getNullRange() -> CXSourceRange;
}
extern "C" {
    pub fn clang_getRange(
        begin: CXSourceLocation,
        end: CXSourceLocation,
    ) -> CXSourceRange;
}
extern "C" {
    pub fn clang_equalRanges(
        range1: CXSourceRange,
        range2: CXSourceRange,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Range_isNull(range: CXSourceRange) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_getExpansionLocation(
        location: CXSourceLocation,
        file: *mut CXFile,
        line: *mut ::std::os::raw::c_uint,
        column: *mut ::std::os::raw::c_uint,
        offset: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_getPresumedLocation(
        location: CXSourceLocation,
        filename: *mut CXString,
        line: *mut ::std::os::raw::c_uint,
        column: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_getInstantiationLocation(
        location: CXSourceLocation,
        file: *mut CXFile,
        line: *mut ::std::os::raw::c_uint,
        column: *mut ::std::os::raw::c_uint,
        offset: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_getSpellingLocation(
        location: CXSourceLocation,
        file: *mut CXFile,
        line: *mut ::std::os::raw::c_uint,
        column: *mut ::std::os::raw::c_uint,
        offset: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_getFileLocation(
        location: CXSourceLocation,
        file: *mut CXFile,
        line: *mut ::std::os::raw::c_uint,
        column: *mut ::std::os::raw::c_uint,
        offset: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_getRangeStart(range: CXSourceRange) -> CXSourceLocation;
}
extern "C" {
    pub fn clang_getRangeEnd(range: CXSourceRange) -> CXSourceLocation;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXSourceRangeList {
    pub count: ::std::os::raw::c_uint,
    pub ranges: *mut CXSourceRange,
}
#[test]
fn bindgen_test_layout_CXSourceRangeList() {
    assert_eq!(
        ::std::mem::size_of::<CXSourceRangeList>(),
        16usize,
        concat!("Size of: ", stringify!(CXSourceRangeList))
    );
    assert_eq!(
        ::std::mem::align_of::<CXSourceRangeList>(),
        8usize,
        concat!("Alignment of ", stringify!(CXSourceRangeList))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXSourceRangeList>())).count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXSourceRangeList),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXSourceRangeList>())).ranges as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXSourceRangeList),
            "::",
            stringify!(ranges)
        )
    );
}
extern "C" {
    pub fn clang_getSkippedRanges(
        tu: CXTranslationUnit,
        file: CXFile,
    ) -> *mut CXSourceRangeList;
}
extern "C" {
    pub fn clang_getAllSkippedRanges(
        tu: CXTranslationUnit,
    ) -> *mut CXSourceRangeList;
}
extern "C" {
    pub fn clang_disposeSourceRangeList(ranges: *mut CXSourceRangeList);
}
pub mod CXDiagnosticSeverity {
    pub type Type = u32;
    pub const CXDiagnostic_Ignored: Type = 0;
    pub const CXDiagnostic_Note: Type = 1;
    pub const CXDiagnostic_Warning: Type = 2;
    pub const CXDiagnostic_Error: Type = 3;
    pub const CXDiagnostic_Fatal: Type = 4;
}
pub type CXDiagnostic = *mut ::std::os::raw::c_void;
pub type CXDiagnosticSet = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn clang_getNumDiagnosticsInSet(
        Diags: CXDiagnosticSet,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getDiagnosticInSet(
        Diags: CXDiagnosticSet,
        Index: ::std::os::raw::c_uint,
    ) -> CXDiagnostic;
}
pub mod CXLoadDiag_Error {
    pub type Type = u32;
    pub const CXLoadDiag_None: Type = 0;
    pub const CXLoadDiag_Unknown: Type = 1;
    pub const CXLoadDiag_CannotLoad: Type = 2;
    pub const CXLoadDiag_InvalidFile: Type = 3;
}
extern "C" {
    pub fn clang_loadDiagnostics(
        file: *const ::std::os::raw::c_char,
        error: *mut CXLoadDiag_Error::Type,
        errorString: *mut CXString,
    ) -> CXDiagnosticSet;
}
extern "C" {
    pub fn clang_disposeDiagnosticSet(Diags: CXDiagnosticSet);
}
extern "C" {
    pub fn clang_getChildDiagnostics(D: CXDiagnostic) -> CXDiagnosticSet;
}
extern "C" {
    pub fn clang_getNumDiagnostics(
        Unit: CXTranslationUnit,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getDiagnostic(
        Unit: CXTranslationUnit,
        Index: ::std::os::raw::c_uint,
    ) -> CXDiagnostic;
}
extern "C" {
    pub fn clang_getDiagnosticSetFromTU(
        Unit: CXTranslationUnit,
    ) -> CXDiagnosticSet;
}
extern "C" {
    pub fn clang_disposeDiagnostic(Diagnostic: CXDiagnostic);
}
pub mod CXDiagnosticDisplayOptions {
    pub type Type = u32;
    pub const CXDiagnostic_DisplaySourceLocation: Type = 1;
    pub const CXDiagnostic_DisplayColumn: Type = 2;
    pub const CXDiagnostic_DisplaySourceRanges: Type = 4;
    pub const CXDiagnostic_DisplayOption: Type = 8;
    pub const CXDiagnostic_DisplayCategoryId: Type = 16;
    pub const CXDiagnostic_DisplayCategoryName: Type = 32;
}
extern "C" {
    pub fn clang_formatDiagnostic(
        Diagnostic: CXDiagnostic,
        Options: ::std::os::raw::c_uint,
    ) -> CXString;
}
extern "C" {
    pub fn clang_defaultDiagnosticDisplayOptions() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getDiagnosticSeverity(
        arg1: CXDiagnostic,
    ) -> CXDiagnosticSeverity::Type;
}
extern "C" {
    pub fn clang_getDiagnosticLocation(arg1: CXDiagnostic) -> CXSourceLocation;
}
extern "C" {
    pub fn clang_getDiagnosticSpelling(arg1: CXDiagnostic) -> CXString;
}
extern "C" {
    pub fn clang_getDiagnosticOption(
        Diag: CXDiagnostic,
        Disable: *mut CXString,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getDiagnosticCategory(
        arg1: CXDiagnostic,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getDiagnosticCategoryName(
        Category: ::std::os::raw::c_uint,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getDiagnosticCategoryText(arg1: CXDiagnostic) -> CXString;
}
extern "C" {
    pub fn clang_getDiagnosticNumRanges(
        arg1: CXDiagnostic,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getDiagnosticRange(
        Diagnostic: CXDiagnostic,
        Range: ::std::os::raw::c_uint,
    ) -> CXSourceRange;
}
extern "C" {
    pub fn clang_getDiagnosticNumFixIts(
        Diagnostic: CXDiagnostic,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getDiagnosticFixIt(
        Diagnostic: CXDiagnostic,
        FixIt: ::std::os::raw::c_uint,
        ReplacementRange: *mut CXSourceRange,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getTranslationUnitSpelling(
        CTUnit: CXTranslationUnit,
    ) -> CXString;
}
extern "C" {
    pub fn clang_createTranslationUnitFromSourceFile(
        CIdx: CXIndex,
        source_filename: *const ::std::os::raw::c_char,
        num_clang_command_line_args: ::std::os::raw::c_int,
        clang_command_line_args: *const *const ::std::os::raw::c_char,
        num_unsaved_files: ::std::os::raw::c_uint,
        unsaved_files: *mut CXUnsavedFile,
    ) -> CXTranslationUnit;
}
extern "C" {
    pub fn clang_createTranslationUnit(
        CIdx: CXIndex,
        ast_filename: *const ::std::os::raw::c_char,
    ) -> CXTranslationUnit;
}
extern "C" {
    pub fn clang_createTranslationUnit2(
        CIdx: CXIndex,
        ast_filename: *const ::std::os::raw::c_char,
        out_TU: *mut CXTranslationUnit,
    ) -> CXErrorCode::Type;
}
pub mod CXTranslationUnit_Flags {
    pub type Type = u32;
    pub const CXTranslationUnit_None: Type = 0;
    pub const CXTranslationUnit_DetailedPreprocessingRecord: Type = 1;
    pub const CXTranslationUnit_Incomplete: Type = 2;
    pub const CXTranslationUnit_PrecompiledPreamble: Type = 4;
    pub const CXTranslationUnit_CacheCompletionResults: Type = 8;
    pub const CXTranslationUnit_ForSerialization: Type = 16;
    pub const CXTranslationUnit_CXXChainedPCH: Type = 32;
    pub const CXTranslationUnit_SkipFunctionBodies: Type = 64;
    pub const CXTranslationUnit_IncludeBriefCommentsInCodeCompletion: Type =
        128;
    pub const CXTranslationUnit_CreatePreambleOnFirstParse: Type = 256;
    pub const CXTranslationUnit_KeepGoing: Type = 512;
    pub const CXTranslationUnit_SingleFileParse: Type = 1024;
    pub const CXTranslationUnit_LimitSkipFunctionBodiesToPreamble: Type = 2048;
    pub const CXTranslationUnit_IncludeAttributedTypes: Type = 4096;
    pub const CXTranslationUnit_VisitImplicitAttributes: Type = 8192;
    pub const CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles: Type = 16384;
}
extern "C" {
    pub fn clang_defaultEditingTranslationUnitOptions() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_parseTranslationUnit(
        CIdx: CXIndex,
        source_filename: *const ::std::os::raw::c_char,
        command_line_args: *const *const ::std::os::raw::c_char,
        num_command_line_args: ::std::os::raw::c_int,
        unsaved_files: *mut CXUnsavedFile,
        num_unsaved_files: ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
    ) -> CXTranslationUnit;
}
extern "C" {
    pub fn clang_parseTranslationUnit2(
        CIdx: CXIndex,
        source_filename: *const ::std::os::raw::c_char,
        command_line_args: *const *const ::std::os::raw::c_char,
        num_command_line_args: ::std::os::raw::c_int,
        unsaved_files: *mut CXUnsavedFile,
        num_unsaved_files: ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
        out_TU: *mut CXTranslationUnit,
    ) -> CXErrorCode::Type;
}
extern "C" {
    pub fn clang_parseTranslationUnit2FullArgv(
        CIdx: CXIndex,
        source_filename: *const ::std::os::raw::c_char,
        command_line_args: *const *const ::std::os::raw::c_char,
        num_command_line_args: ::std::os::raw::c_int,
        unsaved_files: *mut CXUnsavedFile,
        num_unsaved_files: ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
        out_TU: *mut CXTranslationUnit,
    ) -> CXErrorCode::Type;
}
pub mod CXSaveTranslationUnit_Flags {
    pub type Type = u32;
    pub const CXSaveTranslationUnit_None: Type = 0;
}
extern "C" {
    pub fn clang_defaultSaveOptions(
        TU: CXTranslationUnit,
    ) -> ::std::os::raw::c_uint;
}
pub mod CXSaveError {
    pub type Type = u32;
    pub const CXSaveError_None: Type = 0;
    pub const CXSaveError_Unknown: Type = 1;
    pub const CXSaveError_TranslationErrors: Type = 2;
    pub const CXSaveError_InvalidTU: Type = 3;
}
extern "C" {
    pub fn clang_saveTranslationUnit(
        TU: CXTranslationUnit,
        FileName: *const ::std::os::raw::c_char,
        options: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_suspendTranslationUnit(
        arg1: CXTranslationUnit,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_disposeTranslationUnit(arg1: CXTranslationUnit);
}
pub mod CXReparse_Flags {
    pub type Type = u32;
    pub const CXReparse_None: Type = 0;
}
extern "C" {
    pub fn clang_defaultReparseOptions(
        TU: CXTranslationUnit,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_reparseTranslationUnit(
        TU: CXTranslationUnit,
        num_unsaved_files: ::std::os::raw::c_uint,
        unsaved_files: *mut CXUnsavedFile,
        options: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub mod CXTUResourceUsageKind {
    pub type Type = u32;
    pub const CXTUResourceUsage_AST: Type = 1;
    pub const CXTUResourceUsage_Identifiers: Type = 2;
    pub const CXTUResourceUsage_Selectors: Type = 3;
    pub const CXTUResourceUsage_GlobalCompletionResults: Type = 4;
    pub const CXTUResourceUsage_SourceManagerContentCache: Type = 5;
    pub const CXTUResourceUsage_AST_SideTables: Type = 6;
    pub const CXTUResourceUsage_SourceManager_Membuffer_Malloc: Type = 7;
    pub const CXTUResourceUsage_SourceManager_Membuffer_MMap: Type = 8;
    pub const CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc: Type = 9;
    pub const CXTUResourceUsage_ExternalASTSource_Membuffer_MMap: Type = 10;
    pub const CXTUResourceUsage_Preprocessor: Type = 11;
    pub const CXTUResourceUsage_PreprocessingRecord: Type = 12;
    pub const CXTUResourceUsage_SourceManager_DataStructures: Type = 13;
    pub const CXTUResourceUsage_Preprocessor_HeaderSearch: Type = 14;
    pub const CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN: Type = 1;
    pub const CXTUResourceUsage_MEMORY_IN_BYTES_END: Type = 14;
    pub const CXTUResourceUsage_First: Type = 1;
    pub const CXTUResourceUsage_Last: Type = 14;
}
extern "C" {
    pub fn clang_getTUResourceUsageName(
        kind: CXTUResourceUsageKind::Type,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXTUResourceUsageEntry {
    pub kind: CXTUResourceUsageKind::Type,
    pub amount: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_CXTUResourceUsageEntry() {
    assert_eq!(
        ::std::mem::size_of::<CXTUResourceUsageEntry>(),
        16usize,
        concat!("Size of: ", stringify!(CXTUResourceUsageEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<CXTUResourceUsageEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(CXTUResourceUsageEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXTUResourceUsageEntry>())).kind as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXTUResourceUsageEntry),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXTUResourceUsageEntry>())).amount
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXTUResourceUsageEntry),
            "::",
            stringify!(amount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXTUResourceUsage {
    pub data: *mut ::std::os::raw::c_void,
    pub numEntries: ::std::os::raw::c_uint,
    pub entries: *mut CXTUResourceUsageEntry,
}
#[test]
fn bindgen_test_layout_CXTUResourceUsage() {
    assert_eq!(
        ::std::mem::size_of::<CXTUResourceUsage>(),
        24usize,
        concat!("Size of: ", stringify!(CXTUResourceUsage))
    );
    assert_eq!(
        ::std::mem::align_of::<CXTUResourceUsage>(),
        8usize,
        concat!("Alignment of ", stringify!(CXTUResourceUsage))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXTUResourceUsage>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXTUResourceUsage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXTUResourceUsage>())).numEntries as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXTUResourceUsage),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXTUResourceUsage>())).entries as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXTUResourceUsage),
            "::",
            stringify!(entries)
        )
    );
}
extern "C" {
    pub fn clang_getCXTUResourceUsage(
        TU: CXTranslationUnit,
    ) -> CXTUResourceUsage;
}
extern "C" {
    pub fn clang_disposeCXTUResourceUsage(usage: CXTUResourceUsage);
}
extern "C" {
    pub fn clang_getTranslationUnitTargetInfo(
        CTUnit: CXTranslationUnit,
    ) -> CXTargetInfo;
}
extern "C" {
    pub fn clang_TargetInfo_dispose(Info: CXTargetInfo);
}
extern "C" {
    pub fn clang_TargetInfo_getTriple(Info: CXTargetInfo) -> CXString;
}
extern "C" {
    pub fn clang_TargetInfo_getPointerWidth(
        Info: CXTargetInfo,
    ) -> ::std::os::raw::c_int;
}
pub mod CXCursorKind {
    pub type Type = u32;
    pub const CXCursor_UnexposedDecl: Type = 1;
    pub const CXCursor_StructDecl: Type = 2;
    pub const CXCursor_UnionDecl: Type = 3;
    pub const CXCursor_ClassDecl: Type = 4;
    pub const CXCursor_EnumDecl: Type = 5;
    pub const CXCursor_FieldDecl: Type = 6;
    pub const CXCursor_EnumConstantDecl: Type = 7;
    pub const CXCursor_FunctionDecl: Type = 8;
    pub const CXCursor_VarDecl: Type = 9;
    pub const CXCursor_ParmDecl: Type = 10;
    pub const CXCursor_ObjCInterfaceDecl: Type = 11;
    pub const CXCursor_ObjCCategoryDecl: Type = 12;
    pub const CXCursor_ObjCProtocolDecl: Type = 13;
    pub const CXCursor_ObjCPropertyDecl: Type = 14;
    pub const CXCursor_ObjCIvarDecl: Type = 15;
    pub const CXCursor_ObjCInstanceMethodDecl: Type = 16;
    pub const CXCursor_ObjCClassMethodDecl: Type = 17;
    pub const CXCursor_ObjCImplementationDecl: Type = 18;
    pub const CXCursor_ObjCCategoryImplDecl: Type = 19;
    pub const CXCursor_TypedefDecl: Type = 20;
    pub const CXCursor_CXXMethod: Type = 21;
    pub const CXCursor_Namespace: Type = 22;
    pub const CXCursor_LinkageSpec: Type = 23;
    pub const CXCursor_Constructor: Type = 24;
    pub const CXCursor_Destructor: Type = 25;
    pub const CXCursor_ConversionFunction: Type = 26;
    pub const CXCursor_TemplateTypeParameter: Type = 27;
    pub const CXCursor_NonTypeTemplateParameter: Type = 28;
    pub const CXCursor_TemplateTemplateParameter: Type = 29;
    pub const CXCursor_FunctionTemplate: Type = 30;
    pub const CXCursor_ClassTemplate: Type = 31;
    pub const CXCursor_ClassTemplatePartialSpecialization: Type = 32;
    pub const CXCursor_NamespaceAlias: Type = 33;
    pub const CXCursor_UsingDirective: Type = 34;
    pub const CXCursor_UsingDeclaration: Type = 35;
    pub const CXCursor_TypeAliasDecl: Type = 36;
    pub const CXCursor_ObjCSynthesizeDecl: Type = 37;
    pub const CXCursor_ObjCDynamicDecl: Type = 38;
    pub const CXCursor_CXXAccessSpecifier: Type = 39;
    pub const CXCursor_FirstDecl: Type = 1;
    pub const CXCursor_LastDecl: Type = 39;
    pub const CXCursor_FirstRef: Type = 40;
    pub const CXCursor_ObjCSuperClassRef: Type = 40;
    pub const CXCursor_ObjCProtocolRef: Type = 41;
    pub const CXCursor_ObjCClassRef: Type = 42;
    pub const CXCursor_TypeRef: Type = 43;
    pub const CXCursor_CXXBaseSpecifier: Type = 44;
    pub const CXCursor_TemplateRef: Type = 45;
    pub const CXCursor_NamespaceRef: Type = 46;
    pub const CXCursor_MemberRef: Type = 47;
    pub const CXCursor_LabelRef: Type = 48;
    pub const CXCursor_OverloadedDeclRef: Type = 49;
    pub const CXCursor_VariableRef: Type = 50;
    pub const CXCursor_LastRef: Type = 50;
    pub const CXCursor_FirstInvalid: Type = 70;
    pub const CXCursor_InvalidFile: Type = 70;
    pub const CXCursor_NoDeclFound: Type = 71;
    pub const CXCursor_NotImplemented: Type = 72;
    pub const CXCursor_InvalidCode: Type = 73;
    pub const CXCursor_LastInvalid: Type = 73;
    pub const CXCursor_FirstExpr: Type = 100;
    pub const CXCursor_UnexposedExpr: Type = 100;
    pub const CXCursor_DeclRefExpr: Type = 101;
    pub const CXCursor_MemberRefExpr: Type = 102;
    pub const CXCursor_CallExpr: Type = 103;
    pub const CXCursor_ObjCMessageExpr: Type = 104;
    pub const CXCursor_BlockExpr: Type = 105;
    pub const CXCursor_IntegerLiteral: Type = 106;
    pub const CXCursor_FloatingLiteral: Type = 107;
    pub const CXCursor_ImaginaryLiteral: Type = 108;
    pub const CXCursor_StringLiteral: Type = 109;
    pub const CXCursor_CharacterLiteral: Type = 110;
    pub const CXCursor_ParenExpr: Type = 111;
    pub const CXCursor_UnaryOperator: Type = 112;
    pub const CXCursor_ArraySubscriptExpr: Type = 113;
    pub const CXCursor_BinaryOperator: Type = 114;
    pub const CXCursor_CompoundAssignOperator: Type = 115;
    pub const CXCursor_ConditionalOperator: Type = 116;
    pub const CXCursor_CStyleCastExpr: Type = 117;
    pub const CXCursor_CompoundLiteralExpr: Type = 118;
    pub const CXCursor_InitListExpr: Type = 119;
    pub const CXCursor_AddrLabelExpr: Type = 120;
    pub const CXCursor_StmtExpr: Type = 121;
    pub const CXCursor_GenericSelectionExpr: Type = 122;
    pub const CXCursor_GNUNullExpr: Type = 123;
    pub const CXCursor_CXXStaticCastExpr: Type = 124;
    pub const CXCursor_CXXDynamicCastExpr: Type = 125;
    pub const CXCursor_CXXReinterpretCastExpr: Type = 126;
    pub const CXCursor_CXXConstCastExpr: Type = 127;
    pub const CXCursor_CXXFunctionalCastExpr: Type = 128;
    pub const CXCursor_CXXTypeidExpr: Type = 129;
    pub const CXCursor_CXXBoolLiteralExpr: Type = 130;
    pub const CXCursor_CXXNullPtrLiteralExpr: Type = 131;
    pub const CXCursor_CXXThisExpr: Type = 132;
    pub const CXCursor_CXXThrowExpr: Type = 133;
    pub const CXCursor_CXXNewExpr: Type = 134;
    pub const CXCursor_CXXDeleteExpr: Type = 135;
    pub const CXCursor_UnaryExpr: Type = 136;
    pub const CXCursor_ObjCStringLiteral: Type = 137;
    pub const CXCursor_ObjCEncodeExpr: Type = 138;
    pub const CXCursor_ObjCSelectorExpr: Type = 139;
    pub const CXCursor_ObjCProtocolExpr: Type = 140;
    pub const CXCursor_ObjCBridgedCastExpr: Type = 141;
    pub const CXCursor_PackExpansionExpr: Type = 142;
    pub const CXCursor_SizeOfPackExpr: Type = 143;
    pub const CXCursor_LambdaExpr: Type = 144;
    pub const CXCursor_ObjCBoolLiteralExpr: Type = 145;
    pub const CXCursor_ObjCSelfExpr: Type = 146;
    pub const CXCursor_OMPArraySectionExpr: Type = 147;
    pub const CXCursor_ObjCAvailabilityCheckExpr: Type = 148;
    pub const CXCursor_FixedPointLiteral: Type = 149;
    pub const CXCursor_LastExpr: Type = 149;
    pub const CXCursor_FirstStmt: Type = 200;
    pub const CXCursor_UnexposedStmt: Type = 200;
    pub const CXCursor_LabelStmt: Type = 201;
    pub const CXCursor_CompoundStmt: Type = 202;
    pub const CXCursor_CaseStmt: Type = 203;
    pub const CXCursor_DefaultStmt: Type = 204;
    pub const CXCursor_IfStmt: Type = 205;
    pub const CXCursor_SwitchStmt: Type = 206;
    pub const CXCursor_WhileStmt: Type = 207;
    pub const CXCursor_DoStmt: Type = 208;
    pub const CXCursor_ForStmt: Type = 209;
    pub const CXCursor_GotoStmt: Type = 210;
    pub const CXCursor_IndirectGotoStmt: Type = 211;
    pub const CXCursor_ContinueStmt: Type = 212;
    pub const CXCursor_BreakStmt: Type = 213;
    pub const CXCursor_ReturnStmt: Type = 214;
    pub const CXCursor_GCCAsmStmt: Type = 215;
    pub const CXCursor_AsmStmt: Type = 215;
    pub const CXCursor_ObjCAtTryStmt: Type = 216;
    pub const CXCursor_ObjCAtCatchStmt: Type = 217;
    pub const CXCursor_ObjCAtFinallyStmt: Type = 218;
    pub const CXCursor_ObjCAtThrowStmt: Type = 219;
    pub const CXCursor_ObjCAtSynchronizedStmt: Type = 220;
    pub const CXCursor_ObjCAutoreleasePoolStmt: Type = 221;
    pub const CXCursor_ObjCForCollectionStmt: Type = 222;
    pub const CXCursor_CXXCatchStmt: Type = 223;
    pub const CXCursor_CXXTryStmt: Type = 224;
    pub const CXCursor_CXXForRangeStmt: Type = 225;
    pub const CXCursor_SEHTryStmt: Type = 226;
    pub const CXCursor_SEHExceptStmt: Type = 227;
    pub const CXCursor_SEHFinallyStmt: Type = 228;
    pub const CXCursor_MSAsmStmt: Type = 229;
    pub const CXCursor_NullStmt: Type = 230;
    pub const CXCursor_DeclStmt: Type = 231;
    pub const CXCursor_OMPParallelDirective: Type = 232;
    pub const CXCursor_OMPSimdDirective: Type = 233;
    pub const CXCursor_OMPForDirective: Type = 234;
    pub const CXCursor_OMPSectionsDirective: Type = 235;
    pub const CXCursor_OMPSectionDirective: Type = 236;
    pub const CXCursor_OMPSingleDirective: Type = 237;
    pub const CXCursor_OMPParallelForDirective: Type = 238;
    pub const CXCursor_OMPParallelSectionsDirective: Type = 239;
    pub const CXCursor_OMPTaskDirective: Type = 240;
    pub const CXCursor_OMPMasterDirective: Type = 241;
    pub const CXCursor_OMPCriticalDirective: Type = 242;
    pub const CXCursor_OMPTaskyieldDirective: Type = 243;
    pub const CXCursor_OMPBarrierDirective: Type = 244;
    pub const CXCursor_OMPTaskwaitDirective: Type = 245;
    pub const CXCursor_OMPFlushDirective: Type = 246;
    pub const CXCursor_SEHLeaveStmt: Type = 247;
    pub const CXCursor_OMPOrderedDirective: Type = 248;
    pub const CXCursor_OMPAtomicDirective: Type = 249;
    pub const CXCursor_OMPForSimdDirective: Type = 250;
    pub const CXCursor_OMPParallelForSimdDirective: Type = 251;
    pub const CXCursor_OMPTargetDirective: Type = 252;
    pub const CXCursor_OMPTeamsDirective: Type = 253;
    pub const CXCursor_OMPTaskgroupDirective: Type = 254;
    pub const CXCursor_OMPCancellationPointDirective: Type = 255;
    pub const CXCursor_OMPCancelDirective: Type = 256;
    pub const CXCursor_OMPTargetDataDirective: Type = 257;
    pub const CXCursor_OMPTaskLoopDirective: Type = 258;
    pub const CXCursor_OMPTaskLoopSimdDirective: Type = 259;
    pub const CXCursor_OMPDistributeDirective: Type = 260;
    pub const CXCursor_OMPTargetEnterDataDirective: Type = 261;
    pub const CXCursor_OMPTargetExitDataDirective: Type = 262;
    pub const CXCursor_OMPTargetParallelDirective: Type = 263;
    pub const CXCursor_OMPTargetParallelForDirective: Type = 264;
    pub const CXCursor_OMPTargetUpdateDirective: Type = 265;
    pub const CXCursor_OMPDistributeParallelForDirective: Type = 266;
    pub const CXCursor_OMPDistributeParallelForSimdDirective: Type = 267;
    pub const CXCursor_OMPDistributeSimdDirective: Type = 268;
    pub const CXCursor_OMPTargetParallelForSimdDirective: Type = 269;
    pub const CXCursor_OMPTargetSimdDirective: Type = 270;
    pub const CXCursor_OMPTeamsDistributeDirective: Type = 271;
    pub const CXCursor_OMPTeamsDistributeSimdDirective: Type = 272;
    pub const CXCursor_OMPTeamsDistributeParallelForSimdDirective: Type = 273;
    pub const CXCursor_OMPTeamsDistributeParallelForDirective: Type = 274;
    pub const CXCursor_OMPTargetTeamsDirective: Type = 275;
    pub const CXCursor_OMPTargetTeamsDistributeDirective: Type = 276;
    pub const CXCursor_OMPTargetTeamsDistributeParallelForDirective: Type = 277;
    pub const CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective: Type =
        278;
    pub const CXCursor_OMPTargetTeamsDistributeSimdDirective: Type = 279;
    pub const CXCursor_BuiltinBitCastExpr: Type = 280;
    pub const CXCursor_LastStmt: Type = 280;
    pub const CXCursor_TranslationUnit: Type = 300;
    pub const CXCursor_FirstAttr: Type = 400;
    pub const CXCursor_UnexposedAttr: Type = 400;
    pub const CXCursor_IBActionAttr: Type = 401;
    pub const CXCursor_IBOutletAttr: Type = 402;
    pub const CXCursor_IBOutletCollectionAttr: Type = 403;
    pub const CXCursor_CXXFinalAttr: Type = 404;
    pub const CXCursor_CXXOverrideAttr: Type = 405;
    pub const CXCursor_AnnotateAttr: Type = 406;
    pub const CXCursor_AsmLabelAttr: Type = 407;
    pub const CXCursor_PackedAttr: Type = 408;
    pub const CXCursor_PureAttr: Type = 409;
    pub const CXCursor_ConstAttr: Type = 410;
    pub const CXCursor_NoDuplicateAttr: Type = 411;
    pub const CXCursor_CUDAConstantAttr: Type = 412;
    pub const CXCursor_CUDADeviceAttr: Type = 413;
    pub const CXCursor_CUDAGlobalAttr: Type = 414;
    pub const CXCursor_CUDAHostAttr: Type = 415;
    pub const CXCursor_CUDASharedAttr: Type = 416;
    pub const CXCursor_VisibilityAttr: Type = 417;
    pub const CXCursor_DLLExport: Type = 418;
    pub const CXCursor_DLLImport: Type = 419;
    pub const CXCursor_NSReturnsRetained: Type = 420;
    pub const CXCursor_NSReturnsNotRetained: Type = 421;
    pub const CXCursor_NSReturnsAutoreleased: Type = 422;
    pub const CXCursor_NSConsumesSelf: Type = 423;
    pub const CXCursor_NSConsumed: Type = 424;
    pub const CXCursor_ObjCException: Type = 425;
    pub const CXCursor_ObjCNSObject: Type = 426;
    pub const CXCursor_ObjCIndependentClass: Type = 427;
    pub const CXCursor_ObjCPreciseLifetime: Type = 428;
    pub const CXCursor_ObjCReturnsInnerPointer: Type = 429;
    pub const CXCursor_ObjCRequiresSuper: Type = 430;
    pub const CXCursor_ObjCRootClass: Type = 431;
    pub const CXCursor_ObjCSubclassingRestricted: Type = 432;
    pub const CXCursor_ObjCExplicitProtocolImpl: Type = 433;
    pub const CXCursor_ObjCDesignatedInitializer: Type = 434;
    pub const CXCursor_ObjCRuntimeVisible: Type = 435;
    pub const CXCursor_ObjCBoxable: Type = 436;
    pub const CXCursor_FlagEnum: Type = 437;
    pub const CXCursor_ConvergentAttr: Type = 438;
    pub const CXCursor_WarnUnusedAttr: Type = 439;
    pub const CXCursor_WarnUnusedResultAttr: Type = 440;
    pub const CXCursor_AlignedAttr: Type = 441;
    pub const CXCursor_LastAttr: Type = 441;
    pub const CXCursor_PreprocessingDirective: Type = 500;
    pub const CXCursor_MacroDefinition: Type = 501;
    pub const CXCursor_MacroExpansion: Type = 502;
    pub const CXCursor_MacroInstantiation: Type = 502;
    pub const CXCursor_InclusionDirective: Type = 503;
    pub const CXCursor_FirstPreprocessing: Type = 500;
    pub const CXCursor_LastPreprocessing: Type = 503;
    pub const CXCursor_ModuleImportDecl: Type = 600;
    pub const CXCursor_TypeAliasTemplateDecl: Type = 601;
    pub const CXCursor_StaticAssert: Type = 602;
    pub const CXCursor_FriendDecl: Type = 603;
    pub const CXCursor_FirstExtraDecl: Type = 600;
    pub const CXCursor_LastExtraDecl: Type = 603;
    pub const CXCursor_OverloadCandidate: Type = 700;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXCursor {
    pub kind: CXCursorKind::Type,
    pub xdata: ::std::os::raw::c_int,
    pub data: [*const ::std::os::raw::c_void; 3usize],
}
#[test]
fn bindgen_test_layout_CXCursor() {
    assert_eq!(
        ::std::mem::size_of::<CXCursor>(),
        32usize,
        concat!("Size of: ", stringify!(CXCursor))
    );
    assert_eq!(
        ::std::mem::align_of::<CXCursor>(),
        8usize,
        concat!("Alignment of ", stringify!(CXCursor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCursor>())).kind as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCursor),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCursor>())).xdata as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCursor),
            "::",
            stringify!(xdata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCursor>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCursor),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn clang_getNullCursor() -> CXCursor;
}
extern "C" {
    pub fn clang_getTranslationUnitCursor(arg1: CXTranslationUnit) -> CXCursor;
}
extern "C" {
    pub fn clang_equalCursors(
        arg1: CXCursor,
        arg2: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isNull(cursor: CXCursor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_hashCursor(arg1: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCursorKind(arg1: CXCursor) -> CXCursorKind::Type;
}
extern "C" {
    pub fn clang_isDeclaration(
        arg1: CXCursorKind::Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isInvalidDeclaration(arg1: CXCursor)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isReference(
        arg1: CXCursorKind::Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isExpression(
        arg1: CXCursorKind::Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isStatement(
        arg1: CXCursorKind::Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isAttribute(
        arg1: CXCursorKind::Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_hasAttrs(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isInvalid(arg1: CXCursorKind::Type) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isTranslationUnit(
        arg1: CXCursorKind::Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isPreprocessing(
        arg1: CXCursorKind::Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isUnexposed(
        arg1: CXCursorKind::Type,
    ) -> ::std::os::raw::c_uint;
}
pub mod CXLinkageKind {
    pub type Type = u32;
    pub const CXLinkage_Invalid: Type = 0;
    pub const CXLinkage_NoLinkage: Type = 1;
    pub const CXLinkage_Internal: Type = 2;
    pub const CXLinkage_UniqueExternal: Type = 3;
    pub const CXLinkage_External: Type = 4;
}
extern "C" {
    pub fn clang_getCursorLinkage(cursor: CXCursor) -> CXLinkageKind::Type;
}
pub mod CXVisibilityKind {
    pub type Type = u32;
    pub const CXVisibility_Invalid: Type = 0;
    pub const CXVisibility_Hidden: Type = 1;
    pub const CXVisibility_Protected: Type = 2;
    pub const CXVisibility_Default: Type = 3;
}
extern "C" {
    pub fn clang_getCursorVisibility(
        cursor: CXCursor,
    ) -> CXVisibilityKind::Type;
}
extern "C" {
    pub fn clang_getCursorAvailability(
        cursor: CXCursor,
    ) -> CXAvailabilityKind::Type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXPlatformAvailability {
    pub Platform: CXString,
    pub Introduced: CXVersion,
    pub Deprecated: CXVersion,
    pub Obsoleted: CXVersion,
    pub Unavailable: ::std::os::raw::c_int,
    pub Message: CXString,
}
#[test]
fn bindgen_test_layout_CXPlatformAvailability() {
    assert_eq!(
        ::std::mem::size_of::<CXPlatformAvailability>(),
        72usize,
        concat!("Size of: ", stringify!(CXPlatformAvailability))
    );
    assert_eq!(
        ::std::mem::align_of::<CXPlatformAvailability>(),
        8usize,
        concat!("Alignment of ", stringify!(CXPlatformAvailability))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXPlatformAvailability>())).Platform
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXPlatformAvailability),
            "::",
            stringify!(Platform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXPlatformAvailability>())).Introduced
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXPlatformAvailability),
            "::",
            stringify!(Introduced)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXPlatformAvailability>())).Deprecated
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CXPlatformAvailability),
            "::",
            stringify!(Deprecated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXPlatformAvailability>())).Obsoleted
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CXPlatformAvailability),
            "::",
            stringify!(Obsoleted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXPlatformAvailability>())).Unavailable
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CXPlatformAvailability),
            "::",
            stringify!(Unavailable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXPlatformAvailability>())).Message
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CXPlatformAvailability),
            "::",
            stringify!(Message)
        )
    );
}
extern "C" {
    pub fn clang_getCursorPlatformAvailability(
        cursor: CXCursor,
        always_deprecated: *mut ::std::os::raw::c_int,
        deprecated_message: *mut CXString,
        always_unavailable: *mut ::std::os::raw::c_int,
        unavailable_message: *mut CXString,
        availability: *mut CXPlatformAvailability,
        availability_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_disposeCXPlatformAvailability(
        availability: *mut CXPlatformAvailability,
    );
}
pub mod CXLanguageKind {
    pub type Type = u32;
    pub const CXLanguage_Invalid: Type = 0;
    pub const CXLanguage_C: Type = 1;
    pub const CXLanguage_ObjC: Type = 2;
    pub const CXLanguage_CPlusPlus: Type = 3;
}
extern "C" {
    pub fn clang_getCursorLanguage(cursor: CXCursor) -> CXLanguageKind::Type;
}
pub mod CXTLSKind {
    pub type Type = u32;
    pub const CXTLS_None: Type = 0;
    pub const CXTLS_Dynamic: Type = 1;
    pub const CXTLS_Static: Type = 2;
}
extern "C" {
    pub fn clang_getCursorTLSKind(cursor: CXCursor) -> CXTLSKind::Type;
}
extern "C" {
    pub fn clang_Cursor_getTranslationUnit(arg1: CXCursor)
        -> CXTranslationUnit;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXCursorSetImpl {
    _unused: [u8; 0],
}
pub type CXCursorSet = *mut CXCursorSetImpl;
extern "C" {
    pub fn clang_createCXCursorSet() -> CXCursorSet;
}
extern "C" {
    pub fn clang_disposeCXCursorSet(cset: CXCursorSet);
}
extern "C" {
    pub fn clang_CXCursorSet_contains(
        cset: CXCursorSet,
        cursor: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXCursorSet_insert(
        cset: CXCursorSet,
        cursor: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCursorSemanticParent(cursor: CXCursor) -> CXCursor;
}
extern "C" {
    pub fn clang_getCursorLexicalParent(cursor: CXCursor) -> CXCursor;
}
extern "C" {
    pub fn clang_getOverriddenCursors(
        cursor: CXCursor,
        overridden: *mut *mut CXCursor,
        num_overridden: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_disposeOverriddenCursors(overridden: *mut CXCursor);
}
extern "C" {
    pub fn clang_getIncludedFile(cursor: CXCursor) -> CXFile;
}
extern "C" {
    pub fn clang_getCursor(
        arg1: CXTranslationUnit,
        arg2: CXSourceLocation,
    ) -> CXCursor;
}
extern "C" {
    pub fn clang_getCursorLocation(arg1: CXCursor) -> CXSourceLocation;
}
extern "C" {
    pub fn clang_getCursorExtent(arg1: CXCursor) -> CXSourceRange;
}
pub mod CXTypeKind {
    pub type Type = u32;
    pub const CXType_Invalid: Type = 0;
    pub const CXType_Unexposed: Type = 1;
    pub const CXType_Void: Type = 2;
    pub const CXType_Bool: Type = 3;
    pub const CXType_Char_U: Type = 4;
    pub const CXType_UChar: Type = 5;
    pub const CXType_Char16: Type = 6;
    pub const CXType_Char32: Type = 7;
    pub const CXType_UShort: Type = 8;
    pub const CXType_UInt: Type = 9;
    pub const CXType_ULong: Type = 10;
    pub const CXType_ULongLong: Type = 11;
    pub const CXType_UInt128: Type = 12;
    pub const CXType_Char_S: Type = 13;
    pub const CXType_SChar: Type = 14;
    pub const CXType_WChar: Type = 15;
    pub const CXType_Short: Type = 16;
    pub const CXType_Int: Type = 17;
    pub const CXType_Long: Type = 18;
    pub const CXType_LongLong: Type = 19;
    pub const CXType_Int128: Type = 20;
    pub const CXType_Float: Type = 21;
    pub const CXType_Double: Type = 22;
    pub const CXType_LongDouble: Type = 23;
    pub const CXType_NullPtr: Type = 24;
    pub const CXType_Overload: Type = 25;
    pub const CXType_Dependent: Type = 26;
    pub const CXType_ObjCId: Type = 27;
    pub const CXType_ObjCClass: Type = 28;
    pub const CXType_ObjCSel: Type = 29;
    pub const CXType_Float128: Type = 30;
    pub const CXType_Half: Type = 31;
    pub const CXType_Float16: Type = 32;
    pub const CXType_ShortAccum: Type = 33;
    pub const CXType_Accum: Type = 34;
    pub const CXType_LongAccum: Type = 35;
    pub const CXType_UShortAccum: Type = 36;
    pub const CXType_UAccum: Type = 37;
    pub const CXType_ULongAccum: Type = 38;
    pub const CXType_FirstBuiltin: Type = 2;
    pub const CXType_LastBuiltin: Type = 38;
    pub const CXType_Complex: Type = 100;
    pub const CXType_Pointer: Type = 101;
    pub const CXType_BlockPointer: Type = 102;
    pub const CXType_LValueReference: Type = 103;
    pub const CXType_RValueReference: Type = 104;
    pub const CXType_Record: Type = 105;
    pub const CXType_Enum: Type = 106;
    pub const CXType_Typedef: Type = 107;
    pub const CXType_ObjCInterface: Type = 108;
    pub const CXType_ObjCObjectPointer: Type = 109;
    pub const CXType_FunctionNoProto: Type = 110;
    pub const CXType_FunctionProto: Type = 111;
    pub const CXType_ConstantArray: Type = 112;
    pub const CXType_Vector: Type = 113;
    pub const CXType_IncompleteArray: Type = 114;
    pub const CXType_VariableArray: Type = 115;
    pub const CXType_DependentSizedArray: Type = 116;
    pub const CXType_MemberPointer: Type = 117;
    pub const CXType_Auto: Type = 118;
    pub const CXType_Elaborated: Type = 119;
    pub const CXType_Pipe: Type = 120;
    pub const CXType_OCLImage1dRO: Type = 121;
    pub const CXType_OCLImage1dArrayRO: Type = 122;
    pub const CXType_OCLImage1dBufferRO: Type = 123;
    pub const CXType_OCLImage2dRO: Type = 124;
    pub const CXType_OCLImage2dArrayRO: Type = 125;
    pub const CXType_OCLImage2dDepthRO: Type = 126;
    pub const CXType_OCLImage2dArrayDepthRO: Type = 127;
    pub const CXType_OCLImage2dMSAARO: Type = 128;
    pub const CXType_OCLImage2dArrayMSAARO: Type = 129;
    pub const CXType_OCLImage2dMSAADepthRO: Type = 130;
    pub const CXType_OCLImage2dArrayMSAADepthRO: Type = 131;
    pub const CXType_OCLImage3dRO: Type = 132;
    pub const CXType_OCLImage1dWO: Type = 133;
    pub const CXType_OCLImage1dArrayWO: Type = 134;
    pub const CXType_OCLImage1dBufferWO: Type = 135;
    pub const CXType_OCLImage2dWO: Type = 136;
    pub const CXType_OCLImage2dArrayWO: Type = 137;
    pub const CXType_OCLImage2dDepthWO: Type = 138;
    pub const CXType_OCLImage2dArrayDepthWO: Type = 139;
    pub const CXType_OCLImage2dMSAAWO: Type = 140;
    pub const CXType_OCLImage2dArrayMSAAWO: Type = 141;
    pub const CXType_OCLImage2dMSAADepthWO: Type = 142;
    pub const CXType_OCLImage2dArrayMSAADepthWO: Type = 143;
    pub const CXType_OCLImage3dWO: Type = 144;
    pub const CXType_OCLImage1dRW: Type = 145;
    pub const CXType_OCLImage1dArrayRW: Type = 146;
    pub const CXType_OCLImage1dBufferRW: Type = 147;
    pub const CXType_OCLImage2dRW: Type = 148;
    pub const CXType_OCLImage2dArrayRW: Type = 149;
    pub const CXType_OCLImage2dDepthRW: Type = 150;
    pub const CXType_OCLImage2dArrayDepthRW: Type = 151;
    pub const CXType_OCLImage2dMSAARW: Type = 152;
    pub const CXType_OCLImage2dArrayMSAARW: Type = 153;
    pub const CXType_OCLImage2dMSAADepthRW: Type = 154;
    pub const CXType_OCLImage2dArrayMSAADepthRW: Type = 155;
    pub const CXType_OCLImage3dRW: Type = 156;
    pub const CXType_OCLSampler: Type = 157;
    pub const CXType_OCLEvent: Type = 158;
    pub const CXType_OCLQueue: Type = 159;
    pub const CXType_OCLReserveID: Type = 160;
    pub const CXType_ObjCObject: Type = 161;
    pub const CXType_ObjCTypeParam: Type = 162;
    pub const CXType_Attributed: Type = 163;
    pub const CXType_OCLIntelSubgroupAVCMcePayload: Type = 164;
    pub const CXType_OCLIntelSubgroupAVCImePayload: Type = 165;
    pub const CXType_OCLIntelSubgroupAVCRefPayload: Type = 166;
    pub const CXType_OCLIntelSubgroupAVCSicPayload: Type = 167;
    pub const CXType_OCLIntelSubgroupAVCMceResult: Type = 168;
    pub const CXType_OCLIntelSubgroupAVCImeResult: Type = 169;
    pub const CXType_OCLIntelSubgroupAVCRefResult: Type = 170;
    pub const CXType_OCLIntelSubgroupAVCSicResult: Type = 171;
    pub const CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout: Type = 172;
    pub const CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout: Type = 173;
    pub const CXType_OCLIntelSubgroupAVCImeSingleRefStreamin: Type = 174;
    pub const CXType_OCLIntelSubgroupAVCImeDualRefStreamin: Type = 175;
    pub const CXType_ExtVector: Type = 176;
}
pub mod CXCallingConv {
    pub type Type = u32;
    pub const CXCallingConv_Default: Type = 0;
    pub const CXCallingConv_C: Type = 1;
    pub const CXCallingConv_X86StdCall: Type = 2;
    pub const CXCallingConv_X86FastCall: Type = 3;
    pub const CXCallingConv_X86ThisCall: Type = 4;
    pub const CXCallingConv_X86Pascal: Type = 5;
    pub const CXCallingConv_AAPCS: Type = 6;
    pub const CXCallingConv_AAPCS_VFP: Type = 7;
    pub const CXCallingConv_X86RegCall: Type = 8;
    pub const CXCallingConv_IntelOclBicc: Type = 9;
    pub const CXCallingConv_Win64: Type = 10;
    pub const CXCallingConv_X86_64Win64: Type = 10;
    pub const CXCallingConv_X86_64SysV: Type = 11;
    pub const CXCallingConv_X86VectorCall: Type = 12;
    pub const CXCallingConv_Swift: Type = 13;
    pub const CXCallingConv_PreserveMost: Type = 14;
    pub const CXCallingConv_PreserveAll: Type = 15;
    pub const CXCallingConv_AArch64VectorCall: Type = 16;
    pub const CXCallingConv_Invalid: Type = 100;
    pub const CXCallingConv_Unexposed: Type = 200;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXType {
    pub kind: CXTypeKind::Type,
    pub data: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_CXType() {
    assert_eq!(
        ::std::mem::size_of::<CXType>(),
        24usize,
        concat!("Size of: ", stringify!(CXType))
    );
    assert_eq!(
        ::std::mem::align_of::<CXType>(),
        8usize,
        concat!("Alignment of ", stringify!(CXType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CXType>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXType),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CXType>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXType),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn clang_getCursorType(C: CXCursor) -> CXType;
}
extern "C" {
    pub fn clang_getTypeSpelling(CT: CXType) -> CXString;
}
extern "C" {
    pub fn clang_getTypedefDeclUnderlyingType(C: CXCursor) -> CXType;
}
extern "C" {
    pub fn clang_getEnumDeclIntegerType(C: CXCursor) -> CXType;
}
extern "C" {
    pub fn clang_getEnumConstantDeclValue(
        C: CXCursor,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_getEnumConstantDeclUnsignedValue(
        C: CXCursor,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn clang_getFieldDeclBitWidth(C: CXCursor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_Cursor_getNumArguments(C: CXCursor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_Cursor_getArgument(
        C: CXCursor,
        i: ::std::os::raw::c_uint,
    ) -> CXCursor;
}
pub mod CXTemplateArgumentKind {
    pub type Type = u32;
    pub const CXTemplateArgumentKind_Null: Type = 0;
    pub const CXTemplateArgumentKind_Type: Type = 1;
    pub const CXTemplateArgumentKind_Declaration: Type = 2;
    pub const CXTemplateArgumentKind_NullPtr: Type = 3;
    pub const CXTemplateArgumentKind_Integral: Type = 4;
    pub const CXTemplateArgumentKind_Template: Type = 5;
    pub const CXTemplateArgumentKind_TemplateExpansion: Type = 6;
    pub const CXTemplateArgumentKind_Expression: Type = 7;
    pub const CXTemplateArgumentKind_Pack: Type = 8;
    pub const CXTemplateArgumentKind_Invalid: Type = 9;
}
extern "C" {
    pub fn clang_Cursor_getNumTemplateArguments(
        C: CXCursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_Cursor_getTemplateArgumentKind(
        C: CXCursor,
        I: ::std::os::raw::c_uint,
    ) -> CXTemplateArgumentKind::Type;
}
extern "C" {
    pub fn clang_Cursor_getTemplateArgumentType(
        C: CXCursor,
        I: ::std::os::raw::c_uint,
    ) -> CXType;
}
extern "C" {
    pub fn clang_Cursor_getTemplateArgumentValue(
        C: CXCursor,
        I: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_Cursor_getTemplateArgumentUnsignedValue(
        C: CXCursor,
        I: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn clang_equalTypes(A: CXType, B: CXType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCanonicalType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_isConstQualifiedType(T: CXType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isMacroFunctionLike(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isMacroBuiltin(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isFunctionInlined(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isVolatileQualifiedType(T: CXType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isRestrictQualifiedType(T: CXType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getAddressSpace(T: CXType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getTypedefName(CT: CXType) -> CXString;
}
extern "C" {
    pub fn clang_getPointeeType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_getTypeDeclaration(T: CXType) -> CXCursor;
}
extern "C" {
    pub fn clang_getDeclObjCTypeEncoding(C: CXCursor) -> CXString;
}
extern "C" {
    pub fn clang_Type_getObjCEncoding(type_: CXType) -> CXString;
}
extern "C" {
    pub fn clang_getTypeKindSpelling(K: CXTypeKind::Type) -> CXString;
}
extern "C" {
    pub fn clang_getFunctionTypeCallingConv(T: CXType) -> CXCallingConv::Type;
}
extern "C" {
    pub fn clang_getResultType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_getExceptionSpecificationType(
        T: CXType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_getNumArgTypes(T: CXType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_getArgType(T: CXType, i: ::std::os::raw::c_uint) -> CXType;
}
extern "C" {
    pub fn clang_Type_getObjCObjectBaseType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_Type_getNumObjCProtocolRefs(
        T: CXType,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Type_getObjCProtocolDecl(
        T: CXType,
        i: ::std::os::raw::c_uint,
    ) -> CXCursor;
}
extern "C" {
    pub fn clang_Type_getNumObjCTypeArgs(T: CXType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Type_getObjCTypeArg(
        T: CXType,
        i: ::std::os::raw::c_uint,
    ) -> CXType;
}
extern "C" {
    pub fn clang_isFunctionTypeVariadic(T: CXType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCursorResultType(C: CXCursor) -> CXType;
}
extern "C" {
    pub fn clang_getCursorExceptionSpecificationType(
        C: CXCursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_isPODType(T: CXType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getElementType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_getNumElements(T: CXType) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_getArrayElementType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_getArraySize(T: CXType) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_Type_getNamedType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_Type_isTransparentTagTypedef(
        T: CXType,
    ) -> ::std::os::raw::c_uint;
}
pub mod CXTypeNullabilityKind {
    pub type Type = u32;
    pub const CXTypeNullability_NonNull: Type = 0;
    pub const CXTypeNullability_Nullable: Type = 1;
    pub const CXTypeNullability_Unspecified: Type = 2;
    pub const CXTypeNullability_Invalid: Type = 3;
}
extern "C" {
    pub fn clang_Type_getNullability(T: CXType) -> CXTypeNullabilityKind::Type;
}
pub mod CXTypeLayoutError {
    pub type Type = i32;
    pub const CXTypeLayoutError_Invalid: Type = -1;
    pub const CXTypeLayoutError_Incomplete: Type = -2;
    pub const CXTypeLayoutError_Dependent: Type = -3;
    pub const CXTypeLayoutError_NotConstantSize: Type = -4;
    pub const CXTypeLayoutError_InvalidFieldName: Type = -5;
    pub const CXTypeLayoutError_Undeduced: Type = -6;
}
extern "C" {
    pub fn clang_Type_getAlignOf(T: CXType) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_Type_getClassType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_Type_getSizeOf(T: CXType) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_Type_getOffsetOf(
        T: CXType,
        S: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_Type_getModifiedType(T: CXType) -> CXType;
}
extern "C" {
    pub fn clang_Cursor_getOffsetOfField(
        C: CXCursor,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_Cursor_isAnonymous(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isAnonymousRecordDecl(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isInlineNamespace(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
pub mod CXRefQualifierKind {
    pub type Type = u32;
    pub const CXRefQualifier_None: Type = 0;
    pub const CXRefQualifier_LValue: Type = 1;
    pub const CXRefQualifier_RValue: Type = 2;
}
extern "C" {
    pub fn clang_Type_getNumTemplateArguments(
        T: CXType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_Type_getTemplateArgumentAsType(
        T: CXType,
        i: ::std::os::raw::c_uint,
    ) -> CXType;
}
extern "C" {
    pub fn clang_Type_getCXXRefQualifier(T: CXType)
        -> CXRefQualifierKind::Type;
}
extern "C" {
    pub fn clang_Cursor_isBitField(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_isVirtualBase(arg1: CXCursor) -> ::std::os::raw::c_uint;
}
pub mod CX_CXXAccessSpecifier {
    pub type Type = u32;
    pub const CX_CXXInvalidAccessSpecifier: Type = 0;
    pub const CX_CXXPublic: Type = 1;
    pub const CX_CXXProtected: Type = 2;
    pub const CX_CXXPrivate: Type = 3;
}
extern "C" {
    pub fn clang_getCXXAccessSpecifier(
        arg1: CXCursor,
    ) -> CX_CXXAccessSpecifier::Type;
}
pub mod CX_StorageClass {
    pub type Type = u32;
    pub const CX_SC_Invalid: Type = 0;
    pub const CX_SC_None: Type = 1;
    pub const CX_SC_Extern: Type = 2;
    pub const CX_SC_Static: Type = 3;
    pub const CX_SC_PrivateExtern: Type = 4;
    pub const CX_SC_OpenCLWorkGroupLocal: Type = 5;
    pub const CX_SC_Auto: Type = 6;
    pub const CX_SC_Register: Type = 7;
}
extern "C" {
    pub fn clang_Cursor_getStorageClass(
        arg1: CXCursor,
    ) -> CX_StorageClass::Type;
}
extern "C" {
    pub fn clang_getNumOverloadedDecls(
        cursor: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getOverloadedDecl(
        cursor: CXCursor,
        index: ::std::os::raw::c_uint,
    ) -> CXCursor;
}
extern "C" {
    pub fn clang_getIBOutletCollectionType(arg1: CXCursor) -> CXType;
}
pub mod CXChildVisitResult {
    pub type Type = u32;
    pub const CXChildVisit_Break: Type = 0;
    pub const CXChildVisit_Continue: Type = 1;
    pub const CXChildVisit_Recurse: Type = 2;
}
pub type CXCursorVisitor = ::std::option::Option<
    unsafe extern "C" fn(
        cursor: CXCursor,
        parent: CXCursor,
        client_data: CXClientData,
    ) -> CXChildVisitResult::Type,
>;
extern "C" {
    pub fn clang_visitChildren(
        parent: CXCursor,
        visitor: CXCursorVisitor,
        client_data: CXClientData,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCursorUSR(arg1: CXCursor) -> CXString;
}
extern "C" {
    pub fn clang_constructUSR_ObjCClass(
        class_name: *const ::std::os::raw::c_char,
    ) -> CXString;
}
extern "C" {
    pub fn clang_constructUSR_ObjCCategory(
        class_name: *const ::std::os::raw::c_char,
        category_name: *const ::std::os::raw::c_char,
    ) -> CXString;
}
extern "C" {
    pub fn clang_constructUSR_ObjCProtocol(
        protocol_name: *const ::std::os::raw::c_char,
    ) -> CXString;
}
extern "C" {
    pub fn clang_constructUSR_ObjCIvar(
        name: *const ::std::os::raw::c_char,
        classUSR: CXString,
    ) -> CXString;
}
extern "C" {
    pub fn clang_constructUSR_ObjCMethod(
        name: *const ::std::os::raw::c_char,
        isInstanceMethod: ::std::os::raw::c_uint,
        classUSR: CXString,
    ) -> CXString;
}
extern "C" {
    pub fn clang_constructUSR_ObjCProperty(
        property: *const ::std::os::raw::c_char,
        classUSR: CXString,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getCursorSpelling(arg1: CXCursor) -> CXString;
}
extern "C" {
    pub fn clang_Cursor_getSpellingNameRange(
        arg1: CXCursor,
        pieceIndex: ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
    ) -> CXSourceRange;
}
pub type CXPrintingPolicy = *mut ::std::os::raw::c_void;
pub mod CXPrintingPolicyProperty {
    pub type Type = u32;
    pub const CXPrintingPolicy_Indentation: Type = 0;
    pub const CXPrintingPolicy_SuppressSpecifiers: Type = 1;
    pub const CXPrintingPolicy_SuppressTagKeyword: Type = 2;
    pub const CXPrintingPolicy_IncludeTagDefinition: Type = 3;
    pub const CXPrintingPolicy_SuppressScope: Type = 4;
    pub const CXPrintingPolicy_SuppressUnwrittenScope: Type = 5;
    pub const CXPrintingPolicy_SuppressInitializers: Type = 6;
    pub const CXPrintingPolicy_ConstantArraySizeAsWritten: Type = 7;
    pub const CXPrintingPolicy_AnonymousTagLocations: Type = 8;
    pub const CXPrintingPolicy_SuppressStrongLifetime: Type = 9;
    pub const CXPrintingPolicy_SuppressLifetimeQualifiers: Type = 10;
    pub const CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors: Type = 11;
    pub const CXPrintingPolicy_Bool: Type = 12;
    pub const CXPrintingPolicy_Restrict: Type = 13;
    pub const CXPrintingPolicy_Alignof: Type = 14;
    pub const CXPrintingPolicy_UnderscoreAlignof: Type = 15;
    pub const CXPrintingPolicy_UseVoidForZeroParams: Type = 16;
    pub const CXPrintingPolicy_TerseOutput: Type = 17;
    pub const CXPrintingPolicy_PolishForDeclaration: Type = 18;
    pub const CXPrintingPolicy_Half: Type = 19;
    pub const CXPrintingPolicy_MSWChar: Type = 20;
    pub const CXPrintingPolicy_IncludeNewlines: Type = 21;
    pub const CXPrintingPolicy_MSVCFormatting: Type = 22;
    pub const CXPrintingPolicy_ConstantsAsWritten: Type = 23;
    pub const CXPrintingPolicy_SuppressImplicitBase: Type = 24;
    pub const CXPrintingPolicy_FullyQualifiedName: Type = 25;
    pub const CXPrintingPolicy_LastProperty: Type = 25;
}
extern "C" {
    pub fn clang_PrintingPolicy_getProperty(
        Policy: CXPrintingPolicy,
        Property: CXPrintingPolicyProperty::Type,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_PrintingPolicy_setProperty(
        Policy: CXPrintingPolicy,
        Property: CXPrintingPolicyProperty::Type,
        Value: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_getCursorPrintingPolicy(arg1: CXCursor) -> CXPrintingPolicy;
}
extern "C" {
    pub fn clang_PrintingPolicy_dispose(Policy: CXPrintingPolicy);
}
extern "C" {
    pub fn clang_getCursorPrettyPrinted(
        Cursor: CXCursor,
        Policy: CXPrintingPolicy,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getCursorDisplayName(arg1: CXCursor) -> CXString;
}
extern "C" {
    pub fn clang_getCursorReferenced(arg1: CXCursor) -> CXCursor;
}
extern "C" {
    pub fn clang_getCursorDefinition(arg1: CXCursor) -> CXCursor;
}
extern "C" {
    pub fn clang_isCursorDefinition(arg1: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCanonicalCursor(arg1: CXCursor) -> CXCursor;
}
extern "C" {
    pub fn clang_Cursor_getObjCSelectorIndex(
        arg1: CXCursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_Cursor_isDynamicCall(C: CXCursor) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_Cursor_getReceiverType(C: CXCursor) -> CXType;
}
pub mod CXObjCPropertyAttrKind {
    pub type Type = u32;
    pub const CXObjCPropertyAttr_noattr: Type = 0;
    pub const CXObjCPropertyAttr_readonly: Type = 1;
    pub const CXObjCPropertyAttr_getter: Type = 2;
    pub const CXObjCPropertyAttr_assign: Type = 4;
    pub const CXObjCPropertyAttr_readwrite: Type = 8;
    pub const CXObjCPropertyAttr_retain: Type = 16;
    pub const CXObjCPropertyAttr_copy: Type = 32;
    pub const CXObjCPropertyAttr_nonatomic: Type = 64;
    pub const CXObjCPropertyAttr_setter: Type = 128;
    pub const CXObjCPropertyAttr_atomic: Type = 256;
    pub const CXObjCPropertyAttr_weak: Type = 512;
    pub const CXObjCPropertyAttr_strong: Type = 1024;
    pub const CXObjCPropertyAttr_unsafe_unretained: Type = 2048;
    pub const CXObjCPropertyAttr_class: Type = 4096;
}
extern "C" {
    pub fn clang_Cursor_getObjCPropertyAttributes(
        C: CXCursor,
        reserved: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_getObjCPropertyGetterName(C: CXCursor) -> CXString;
}
extern "C" {
    pub fn clang_Cursor_getObjCPropertySetterName(C: CXCursor) -> CXString;
}
pub mod CXObjCDeclQualifierKind {
    pub type Type = u32;
    pub const CXObjCDeclQualifier_None: Type = 0;
    pub const CXObjCDeclQualifier_In: Type = 1;
    pub const CXObjCDeclQualifier_Inout: Type = 2;
    pub const CXObjCDeclQualifier_Out: Type = 4;
    pub const CXObjCDeclQualifier_Bycopy: Type = 8;
    pub const CXObjCDeclQualifier_Byref: Type = 16;
    pub const CXObjCDeclQualifier_Oneway: Type = 32;
}
extern "C" {
    pub fn clang_Cursor_getObjCDeclQualifiers(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isObjCOptional(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isVariadic(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_isExternalSymbol(
        C: CXCursor,
        language: *mut CXString,
        definedIn: *mut CXString,
        isGenerated: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Cursor_getCommentRange(C: CXCursor) -> CXSourceRange;
}
extern "C" {
    pub fn clang_Cursor_getRawCommentText(C: CXCursor) -> CXString;
}
extern "C" {
    pub fn clang_Cursor_getBriefCommentText(C: CXCursor) -> CXString;
}
extern "C" {
    pub fn clang_Cursor_getMangling(arg1: CXCursor) -> CXString;
}
extern "C" {
    pub fn clang_Cursor_getCXXManglings(arg1: CXCursor) -> *mut CXStringSet;
}
extern "C" {
    pub fn clang_Cursor_getObjCManglings(arg1: CXCursor) -> *mut CXStringSet;
}
pub type CXModule = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn clang_Cursor_getModule(C: CXCursor) -> CXModule;
}
extern "C" {
    pub fn clang_getModuleForFile(
        arg1: CXTranslationUnit,
        arg2: CXFile,
    ) -> CXModule;
}
extern "C" {
    pub fn clang_Module_getASTFile(Module: CXModule) -> CXFile;
}
extern "C" {
    pub fn clang_Module_getParent(Module: CXModule) -> CXModule;
}
extern "C" {
    pub fn clang_Module_getName(Module: CXModule) -> CXString;
}
extern "C" {
    pub fn clang_Module_getFullName(Module: CXModule) -> CXString;
}
extern "C" {
    pub fn clang_Module_isSystem(Module: CXModule) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_Module_getNumTopLevelHeaders(
        arg1: CXTranslationUnit,
        Module: CXModule,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Module_getTopLevelHeader(
        arg1: CXTranslationUnit,
        Module: CXModule,
        Index: ::std::os::raw::c_uint,
    ) -> CXFile;
}
extern "C" {
    pub fn clang_CXXConstructor_isConvertingConstructor(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXConstructor_isCopyConstructor(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXConstructor_isDefaultConstructor(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXConstructor_isMoveConstructor(
        C: CXCursor,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXField_isMutable(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXMethod_isDefaulted(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXMethod_isPureVirtual(C: CXCursor)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXMethod_isStatic(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXMethod_isVirtual(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXRecord_isAbstract(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_EnumDecl_isScoped(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_CXXMethod_isConst(C: CXCursor) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getTemplateCursorKind(C: CXCursor) -> CXCursorKind::Type;
}
extern "C" {
    pub fn clang_getSpecializedCursorTemplate(C: CXCursor) -> CXCursor;
}
extern "C" {
    pub fn clang_getCursorReferenceNameRange(
        C: CXCursor,
        NameFlags: ::std::os::raw::c_uint,
        PieceIndex: ::std::os::raw::c_uint,
    ) -> CXSourceRange;
}
pub mod CXNameRefFlags {
    pub type Type = u32;
    pub const CXNameRange_WantQualifier: Type = 1;
    pub const CXNameRange_WantTemplateArgs: Type = 2;
    pub const CXNameRange_WantSinglePiece: Type = 4;
}
pub mod CXTokenKind {
    pub type Type = u32;
    pub const CXToken_Punctuation: Type = 0;
    pub const CXToken_Keyword: Type = 1;
    pub const CXToken_Identifier: Type = 2;
    pub const CXToken_Literal: Type = 3;
    pub const CXToken_Comment: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXToken {
    pub int_data: [::std::os::raw::c_uint; 4usize],
    pub ptr_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CXToken() {
    assert_eq!(
        ::std::mem::size_of::<CXToken>(),
        24usize,
        concat!("Size of: ", stringify!(CXToken))
    );
    assert_eq!(
        ::std::mem::align_of::<CXToken>(),
        8usize,
        concat!("Alignment of ", stringify!(CXToken))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXToken>())).int_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXToken),
            "::",
            stringify!(int_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXToken>())).ptr_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXToken),
            "::",
            stringify!(ptr_data)
        )
    );
}
extern "C" {
    pub fn clang_getToken(
        TU: CXTranslationUnit,
        Location: CXSourceLocation,
    ) -> *mut CXToken;
}
extern "C" {
    pub fn clang_getTokenKind(arg1: CXToken) -> CXTokenKind::Type;
}
extern "C" {
    pub fn clang_getTokenSpelling(
        arg1: CXTranslationUnit,
        arg2: CXToken,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getTokenLocation(
        arg1: CXTranslationUnit,
        arg2: CXToken,
    ) -> CXSourceLocation;
}
extern "C" {
    pub fn clang_getTokenExtent(
        arg1: CXTranslationUnit,
        arg2: CXToken,
    ) -> CXSourceRange;
}
extern "C" {
    pub fn clang_tokenize(
        TU: CXTranslationUnit,
        Range: CXSourceRange,
        Tokens: *mut *mut CXToken,
        NumTokens: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_annotateTokens(
        TU: CXTranslationUnit,
        Tokens: *mut CXToken,
        NumTokens: ::std::os::raw::c_uint,
        Cursors: *mut CXCursor,
    );
}
extern "C" {
    pub fn clang_disposeTokens(
        TU: CXTranslationUnit,
        Tokens: *mut CXToken,
        NumTokens: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_getCursorKindSpelling(Kind: CXCursorKind::Type) -> CXString;
}
extern "C" {
    pub fn clang_getDefinitionSpellingAndExtent(
        arg1: CXCursor,
        startBuf: *mut *const ::std::os::raw::c_char,
        endBuf: *mut *const ::std::os::raw::c_char,
        startLine: *mut ::std::os::raw::c_uint,
        startColumn: *mut ::std::os::raw::c_uint,
        endLine: *mut ::std::os::raw::c_uint,
        endColumn: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_enableStackTraces();
}
extern "C" {
    pub fn clang_executeOnThread(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
        user_data: *mut ::std::os::raw::c_void,
        stack_size: ::std::os::raw::c_uint,
    );
}
pub type CXCompletionString = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXCompletionResult {
    pub CursorKind: CXCursorKind::Type,
    pub CompletionString: CXCompletionString,
}
#[test]
fn bindgen_test_layout_CXCompletionResult() {
    assert_eq!(
        ::std::mem::size_of::<CXCompletionResult>(),
        16usize,
        concat!("Size of: ", stringify!(CXCompletionResult))
    );
    assert_eq!(
        ::std::mem::align_of::<CXCompletionResult>(),
        8usize,
        concat!("Alignment of ", stringify!(CXCompletionResult))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCompletionResult>())).CursorKind
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCompletionResult),
            "::",
            stringify!(CursorKind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCompletionResult>())).CompletionString
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCompletionResult),
            "::",
            stringify!(CompletionString)
        )
    );
}
pub mod CXCompletionChunkKind {
    pub type Type = u32;
    pub const CXCompletionChunk_Optional: Type = 0;
    pub const CXCompletionChunk_TypedText: Type = 1;
    pub const CXCompletionChunk_Text: Type = 2;
    pub const CXCompletionChunk_Placeholder: Type = 3;
    pub const CXCompletionChunk_Informative: Type = 4;
    pub const CXCompletionChunk_CurrentParameter: Type = 5;
    pub const CXCompletionChunk_LeftParen: Type = 6;
    pub const CXCompletionChunk_RightParen: Type = 7;
    pub const CXCompletionChunk_LeftBracket: Type = 8;
    pub const CXCompletionChunk_RightBracket: Type = 9;
    pub const CXCompletionChunk_LeftBrace: Type = 10;
    pub const CXCompletionChunk_RightBrace: Type = 11;
    pub const CXCompletionChunk_LeftAngle: Type = 12;
    pub const CXCompletionChunk_RightAngle: Type = 13;
    pub const CXCompletionChunk_Comma: Type = 14;
    pub const CXCompletionChunk_ResultType: Type = 15;
    pub const CXCompletionChunk_Colon: Type = 16;
    pub const CXCompletionChunk_SemiColon: Type = 17;
    pub const CXCompletionChunk_Equal: Type = 18;
    pub const CXCompletionChunk_HorizontalSpace: Type = 19;
    pub const CXCompletionChunk_VerticalSpace: Type = 20;
}
extern "C" {
    pub fn clang_getCompletionChunkKind(
        completion_string: CXCompletionString,
        chunk_number: ::std::os::raw::c_uint,
    ) -> CXCompletionChunkKind::Type;
}
extern "C" {
    pub fn clang_getCompletionChunkText(
        completion_string: CXCompletionString,
        chunk_number: ::std::os::raw::c_uint,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getCompletionChunkCompletionString(
        completion_string: CXCompletionString,
        chunk_number: ::std::os::raw::c_uint,
    ) -> CXCompletionString;
}
extern "C" {
    pub fn clang_getNumCompletionChunks(
        completion_string: CXCompletionString,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCompletionPriority(
        completion_string: CXCompletionString,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCompletionAvailability(
        completion_string: CXCompletionString,
    ) -> CXAvailabilityKind::Type;
}
extern "C" {
    pub fn clang_getCompletionNumAnnotations(
        completion_string: CXCompletionString,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCompletionAnnotation(
        completion_string: CXCompletionString,
        annotation_number: ::std::os::raw::c_uint,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getCompletionParent(
        completion_string: CXCompletionString,
        kind: *mut CXCursorKind::Type,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getCompletionBriefComment(
        completion_string: CXCompletionString,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getCursorCompletionString(
        cursor: CXCursor,
    ) -> CXCompletionString;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXCodeCompleteResults {
    pub Results: *mut CXCompletionResult,
    pub NumResults: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXCodeCompleteResults() {
    assert_eq!(
        ::std::mem::size_of::<CXCodeCompleteResults>(),
        16usize,
        concat!("Size of: ", stringify!(CXCodeCompleteResults))
    );
    assert_eq!(
        ::std::mem::align_of::<CXCodeCompleteResults>(),
        8usize,
        concat!("Alignment of ", stringify!(CXCodeCompleteResults))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCodeCompleteResults>())).Results
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCodeCompleteResults),
            "::",
            stringify!(Results)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCodeCompleteResults>())).NumResults
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCodeCompleteResults),
            "::",
            stringify!(NumResults)
        )
    );
}
extern "C" {
    pub fn clang_getCompletionNumFixIts(
        results: *mut CXCodeCompleteResults,
        completion_index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_getCompletionFixIt(
        results: *mut CXCodeCompleteResults,
        completion_index: ::std::os::raw::c_uint,
        fixit_index: ::std::os::raw::c_uint,
        replacement_range: *mut CXSourceRange,
    ) -> CXString;
}
pub mod CXCodeComplete_Flags {
    pub type Type = u32;
    pub const CXCodeComplete_IncludeMacros: Type = 1;
    pub const CXCodeComplete_IncludeCodePatterns: Type = 2;
    pub const CXCodeComplete_IncludeBriefComments: Type = 4;
    pub const CXCodeComplete_SkipPreamble: Type = 8;
    pub const CXCodeComplete_IncludeCompletionsWithFixIts: Type = 16;
}
pub mod CXCompletionContext {
    pub type Type = u32;
    pub const CXCompletionContext_Unexposed: Type = 0;
    pub const CXCompletionContext_AnyType: Type = 1;
    pub const CXCompletionContext_AnyValue: Type = 2;
    pub const CXCompletionContext_ObjCObjectValue: Type = 4;
    pub const CXCompletionContext_ObjCSelectorValue: Type = 8;
    pub const CXCompletionContext_CXXClassTypeValue: Type = 16;
    pub const CXCompletionContext_DotMemberAccess: Type = 32;
    pub const CXCompletionContext_ArrowMemberAccess: Type = 64;
    pub const CXCompletionContext_ObjCPropertyAccess: Type = 128;
    pub const CXCompletionContext_EnumTag: Type = 256;
    pub const CXCompletionContext_UnionTag: Type = 512;
    pub const CXCompletionContext_StructTag: Type = 1024;
    pub const CXCompletionContext_ClassTag: Type = 2048;
    pub const CXCompletionContext_Namespace: Type = 4096;
    pub const CXCompletionContext_NestedNameSpecifier: Type = 8192;
    pub const CXCompletionContext_ObjCInterface: Type = 16384;
    pub const CXCompletionContext_ObjCProtocol: Type = 32768;
    pub const CXCompletionContext_ObjCCategory: Type = 65536;
    pub const CXCompletionContext_ObjCInstanceMessage: Type = 131072;
    pub const CXCompletionContext_ObjCClassMessage: Type = 262144;
    pub const CXCompletionContext_ObjCSelectorName: Type = 524288;
    pub const CXCompletionContext_MacroName: Type = 1048576;
    pub const CXCompletionContext_NaturalLanguage: Type = 2097152;
    pub const CXCompletionContext_IncludedFile: Type = 4194304;
    pub const CXCompletionContext_Unknown: Type = 8388607;
}
extern "C" {
    pub fn clang_defaultCodeCompleteOptions() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_codeCompleteAt(
        TU: CXTranslationUnit,
        complete_filename: *const ::std::os::raw::c_char,
        complete_line: ::std::os::raw::c_uint,
        complete_column: ::std::os::raw::c_uint,
        unsaved_files: *mut CXUnsavedFile,
        num_unsaved_files: ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
    ) -> *mut CXCodeCompleteResults;
}
extern "C" {
    pub fn clang_sortCodeCompletionResults(
        Results: *mut CXCompletionResult,
        NumResults: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_disposeCodeCompleteResults(
        Results: *mut CXCodeCompleteResults,
    );
}
extern "C" {
    pub fn clang_codeCompleteGetNumDiagnostics(
        Results: *mut CXCodeCompleteResults,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_codeCompleteGetDiagnostic(
        Results: *mut CXCodeCompleteResults,
        Index: ::std::os::raw::c_uint,
    ) -> CXDiagnostic;
}
extern "C" {
    pub fn clang_codeCompleteGetContexts(
        Results: *mut CXCodeCompleteResults,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn clang_codeCompleteGetContainerKind(
        Results: *mut CXCodeCompleteResults,
        IsIncomplete: *mut ::std::os::raw::c_uint,
    ) -> CXCursorKind::Type;
}
extern "C" {
    pub fn clang_codeCompleteGetContainerUSR(
        Results: *mut CXCodeCompleteResults,
    ) -> CXString;
}
extern "C" {
    pub fn clang_codeCompleteGetObjCSelector(
        Results: *mut CXCodeCompleteResults,
    ) -> CXString;
}
extern "C" {
    pub fn clang_getClangVersion() -> CXString;
}
extern "C" {
    pub fn clang_toggleCrashRecovery(isEnabled: ::std::os::raw::c_uint);
}
pub type CXInclusionVisitor = ::std::option::Option<
    unsafe extern "C" fn(
        included_file: CXFile,
        inclusion_stack: *mut CXSourceLocation,
        include_len: ::std::os::raw::c_uint,
        client_data: CXClientData,
    ),
>;
extern "C" {
    pub fn clang_getInclusions(
        tu: CXTranslationUnit,
        visitor: CXInclusionVisitor,
        client_data: CXClientData,
    );
}
pub mod CXEvalResultKind {
    pub type Type = u32;
    pub const CXEval_Int: Type = 1;
    pub const CXEval_Float: Type = 2;
    pub const CXEval_ObjCStrLiteral: Type = 3;
    pub const CXEval_StrLiteral: Type = 4;
    pub const CXEval_CFStr: Type = 5;
    pub const CXEval_Other: Type = 6;
    pub const CXEval_UnExposed: Type = 0;
}
pub type CXEvalResult = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn clang_Cursor_Evaluate(C: CXCursor) -> CXEvalResult;
}
extern "C" {
    pub fn clang_EvalResult_getKind(E: CXEvalResult) -> CXEvalResultKind::Type;
}
extern "C" {
    pub fn clang_EvalResult_getAsInt(E: CXEvalResult) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_EvalResult_getAsLongLong(
        E: CXEvalResult,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn clang_EvalResult_isUnsignedInt(
        E: CXEvalResult,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_EvalResult_getAsUnsigned(
        E: CXEvalResult,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn clang_EvalResult_getAsDouble(E: CXEvalResult) -> f64;
}
extern "C" {
    pub fn clang_EvalResult_getAsStr(
        E: CXEvalResult,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn clang_EvalResult_dispose(E: CXEvalResult);
}
pub type CXRemapping = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn clang_getRemappings(
        path: *const ::std::os::raw::c_char,
    ) -> CXRemapping;
}
extern "C" {
    pub fn clang_getRemappingsFromFileList(
        filePaths: *mut *const ::std::os::raw::c_char,
        numFiles: ::std::os::raw::c_uint,
    ) -> CXRemapping;
}
extern "C" {
    pub fn clang_remap_getNumFiles(arg1: CXRemapping)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_remap_getFilenames(
        arg1: CXRemapping,
        index: ::std::os::raw::c_uint,
        original: *mut CXString,
        transformed: *mut CXString,
    );
}
extern "C" {
    pub fn clang_remap_dispose(arg1: CXRemapping);
}
pub mod CXVisitorResult {
    pub type Type = u32;
    pub const CXVisit_Break: Type = 0;
    pub const CXVisit_Continue: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXCursorAndRangeVisitor {
    pub context: *mut ::std::os::raw::c_void,
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            arg1: CXCursor,
            arg2: CXSourceRange,
        ) -> CXVisitorResult::Type,
    >,
}
#[test]
fn bindgen_test_layout_CXCursorAndRangeVisitor() {
    assert_eq!(
        ::std::mem::size_of::<CXCursorAndRangeVisitor>(),
        16usize,
        concat!("Size of: ", stringify!(CXCursorAndRangeVisitor))
    );
    assert_eq!(
        ::std::mem::align_of::<CXCursorAndRangeVisitor>(),
        8usize,
        concat!("Alignment of ", stringify!(CXCursorAndRangeVisitor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCursorAndRangeVisitor>())).context
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCursorAndRangeVisitor),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXCursorAndRangeVisitor>())).visit
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXCursorAndRangeVisitor),
            "::",
            stringify!(visit)
        )
    );
}
pub mod CXResult {
    pub type Type = u32;
    pub const CXResult_Success: Type = 0;
    pub const CXResult_Invalid: Type = 1;
    pub const CXResult_VisitBreak: Type = 2;
}
extern "C" {
    pub fn clang_findReferencesInFile(
        cursor: CXCursor,
        file: CXFile,
        visitor: CXCursorAndRangeVisitor,
    ) -> CXResult::Type;
}
extern "C" {
    pub fn clang_findIncludesInFile(
        TU: CXTranslationUnit,
        file: CXFile,
        visitor: CXCursorAndRangeVisitor,
    ) -> CXResult::Type;
}
pub type CXIdxClientFile = *mut ::std::os::raw::c_void;
pub type CXIdxClientEntity = *mut ::std::os::raw::c_void;
pub type CXIdxClientContainer = *mut ::std::os::raw::c_void;
pub type CXIdxClientASTFile = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxLoc {
    pub ptr_data: [*mut ::std::os::raw::c_void; 2usize],
    pub int_data: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXIdxLoc() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxLoc>(),
        24usize,
        concat!("Size of: ", stringify!(CXIdxLoc))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxLoc>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxLoc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxLoc>())).ptr_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxLoc),
            "::",
            stringify!(ptr_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxLoc>())).int_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxLoc),
            "::",
            stringify!(int_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxIncludedFileInfo {
    pub hashLoc: CXIdxLoc,
    pub filename: *const ::std::os::raw::c_char,
    pub file: CXFile,
    pub isImport: ::std::os::raw::c_int,
    pub isAngled: ::std::os::raw::c_int,
    pub isModuleImport: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CXIdxIncludedFileInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxIncludedFileInfo>(),
        56usize,
        concat!("Size of: ", stringify!(CXIdxIncludedFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxIncludedFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxIncludedFileInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIncludedFileInfo>())).hashLoc
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIncludedFileInfo),
            "::",
            stringify!(hashLoc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIncludedFileInfo>())).filename
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIncludedFileInfo),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIncludedFileInfo>())).file as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIncludedFileInfo),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIncludedFileInfo>())).isImport
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIncludedFileInfo),
            "::",
            stringify!(isImport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIncludedFileInfo>())).isAngled
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIncludedFileInfo),
            "::",
            stringify!(isAngled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIncludedFileInfo>())).isModuleImport
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIncludedFileInfo),
            "::",
            stringify!(isModuleImport)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxImportedASTFileInfo {
    pub file: CXFile,
    pub module: CXModule,
    pub loc: CXIdxLoc,
    pub isImplicit: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CXIdxImportedASTFileInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxImportedASTFileInfo>(),
        48usize,
        concat!("Size of: ", stringify!(CXIdxImportedASTFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxImportedASTFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxImportedASTFileInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxImportedASTFileInfo>())).file
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxImportedASTFileInfo),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxImportedASTFileInfo>())).module
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxImportedASTFileInfo),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxImportedASTFileInfo>())).loc as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxImportedASTFileInfo),
            "::",
            stringify!(loc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxImportedASTFileInfo>())).isImplicit
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxImportedASTFileInfo),
            "::",
            stringify!(isImplicit)
        )
    );
}
pub mod CXIdxEntityKind {
    pub type Type = u32;
    pub const CXIdxEntity_Unexposed: Type = 0;
    pub const CXIdxEntity_Typedef: Type = 1;
    pub const CXIdxEntity_Function: Type = 2;
    pub const CXIdxEntity_Variable: Type = 3;
    pub const CXIdxEntity_Field: Type = 4;
    pub const CXIdxEntity_EnumConstant: Type = 5;
    pub const CXIdxEntity_ObjCClass: Type = 6;
    pub const CXIdxEntity_ObjCProtocol: Type = 7;
    pub const CXIdxEntity_ObjCCategory: Type = 8;
    pub const CXIdxEntity_ObjCInstanceMethod: Type = 9;
    pub const CXIdxEntity_ObjCClassMethod: Type = 10;
    pub const CXIdxEntity_ObjCProperty: Type = 11;
    pub const CXIdxEntity_ObjCIvar: Type = 12;
    pub const CXIdxEntity_Enum: Type = 13;
    pub const CXIdxEntity_Struct: Type = 14;
    pub const CXIdxEntity_Union: Type = 15;
    pub const CXIdxEntity_CXXClass: Type = 16;
    pub const CXIdxEntity_CXXNamespace: Type = 17;
    pub const CXIdxEntity_CXXNamespaceAlias: Type = 18;
    pub const CXIdxEntity_CXXStaticVariable: Type = 19;
    pub const CXIdxEntity_CXXStaticMethod: Type = 20;
    pub const CXIdxEntity_CXXInstanceMethod: Type = 21;
    pub const CXIdxEntity_CXXConstructor: Type = 22;
    pub const CXIdxEntity_CXXDestructor: Type = 23;
    pub const CXIdxEntity_CXXConversionFunction: Type = 24;
    pub const CXIdxEntity_CXXTypeAlias: Type = 25;
    pub const CXIdxEntity_CXXInterface: Type = 26;
}
pub mod CXIdxEntityLanguage {
    pub type Type = u32;
    pub const CXIdxEntityLang_None: Type = 0;
    pub const CXIdxEntityLang_C: Type = 1;
    pub const CXIdxEntityLang_ObjC: Type = 2;
    pub const CXIdxEntityLang_CXX: Type = 3;
    pub const CXIdxEntityLang_Swift: Type = 4;
}
pub mod CXIdxEntityCXXTemplateKind {
    pub type Type = u32;
    pub const CXIdxEntity_NonTemplate: Type = 0;
    pub const CXIdxEntity_Template: Type = 1;
    pub const CXIdxEntity_TemplatePartialSpecialization: Type = 2;
    pub const CXIdxEntity_TemplateSpecialization: Type = 3;
}
pub mod CXIdxAttrKind {
    pub type Type = u32;
    pub const CXIdxAttr_Unexposed: Type = 0;
    pub const CXIdxAttr_IBAction: Type = 1;
    pub const CXIdxAttr_IBOutlet: Type = 2;
    pub const CXIdxAttr_IBOutletCollection: Type = 3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxAttrInfo {
    pub kind: CXIdxAttrKind::Type,
    pub cursor: CXCursor,
    pub loc: CXIdxLoc,
}
#[test]
fn bindgen_test_layout_CXIdxAttrInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxAttrInfo>(),
        64usize,
        concat!("Size of: ", stringify!(CXIdxAttrInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxAttrInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxAttrInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxAttrInfo>())).kind as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxAttrInfo),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxAttrInfo>())).cursor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxAttrInfo),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxAttrInfo>())).loc as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxAttrInfo),
            "::",
            stringify!(loc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxEntityInfo {
    pub kind: CXIdxEntityKind::Type,
    pub templateKind: CXIdxEntityCXXTemplateKind::Type,
    pub lang: CXIdxEntityLanguage::Type,
    pub name: *const ::std::os::raw::c_char,
    pub USR: *const ::std::os::raw::c_char,
    pub cursor: CXCursor,
    pub attributes: *const *const CXIdxAttrInfo,
    pub numAttributes: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXIdxEntityInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxEntityInfo>(),
        80usize,
        concat!("Size of: ", stringify!(CXIdxEntityInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxEntityInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxEntityInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityInfo>())).kind as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityInfo),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityInfo>())).templateKind as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityInfo),
            "::",
            stringify!(templateKind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityInfo>())).lang as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityInfo),
            "::",
            stringify!(lang)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityInfo>())).name as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityInfo>())).USR as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityInfo),
            "::",
            stringify!(USR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityInfo>())).cursor as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityInfo),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityInfo>())).attributes as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityInfo),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityInfo>())).numAttributes
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityInfo),
            "::",
            stringify!(numAttributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxContainerInfo {
    pub cursor: CXCursor,
}
#[test]
fn bindgen_test_layout_CXIdxContainerInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxContainerInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CXIdxContainerInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxContainerInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxContainerInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxContainerInfo>())).cursor as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxContainerInfo),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxIBOutletCollectionAttrInfo {
    pub attrInfo: *const CXIdxAttrInfo,
    pub objcClass: *const CXIdxEntityInfo,
    pub classCursor: CXCursor,
    pub classLoc: CXIdxLoc,
}
#[test]
fn bindgen_test_layout_CXIdxIBOutletCollectionAttrInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxIBOutletCollectionAttrInfo>(),
        72usize,
        concat!("Size of: ", stringify!(CXIdxIBOutletCollectionAttrInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxIBOutletCollectionAttrInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxIBOutletCollectionAttrInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIBOutletCollectionAttrInfo>())).attrInfo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIBOutletCollectionAttrInfo),
            "::",
            stringify!(attrInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIBOutletCollectionAttrInfo>()))
                .objcClass as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIBOutletCollectionAttrInfo),
            "::",
            stringify!(objcClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIBOutletCollectionAttrInfo>()))
                .classCursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIBOutletCollectionAttrInfo),
            "::",
            stringify!(classCursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxIBOutletCollectionAttrInfo>())).classLoc
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxIBOutletCollectionAttrInfo),
            "::",
            stringify!(classLoc)
        )
    );
}
pub mod CXIdxDeclInfoFlags {
    pub type Type = u32;
    pub const CXIdxDeclFlag_Skipped: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxDeclInfo {
    pub entityInfo: *const CXIdxEntityInfo,
    pub cursor: CXCursor,
    pub loc: CXIdxLoc,
    pub semanticContainer: *const CXIdxContainerInfo,
    pub lexicalContainer: *const CXIdxContainerInfo,
    pub isRedeclaration: ::std::os::raw::c_int,
    pub isDefinition: ::std::os::raw::c_int,
    pub isContainer: ::std::os::raw::c_int,
    pub declAsContainer: *const CXIdxContainerInfo,
    pub isImplicit: ::std::os::raw::c_int,
    pub attributes: *const *const CXIdxAttrInfo,
    pub numAttributes: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXIdxDeclInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxDeclInfo>(),
        128usize,
        concat!("Size of: ", stringify!(CXIdxDeclInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxDeclInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxDeclInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).entityInfo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(entityInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).cursor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).loc as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(loc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).semanticContainer
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(semanticContainer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).lexicalContainer
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(lexicalContainer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).isRedeclaration
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(isRedeclaration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).isDefinition as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(isDefinition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).isContainer as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(isContainer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).declAsContainer
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(declAsContainer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).isImplicit as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(isImplicit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).attributes as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).numAttributes as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(numAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxDeclInfo>())).flags as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxDeclInfo),
            "::",
            stringify!(flags)
        )
    );
}
pub mod CXIdxObjCContainerKind {
    pub type Type = u32;
    pub const CXIdxObjCContainer_ForwardRef: Type = 0;
    pub const CXIdxObjCContainer_Interface: Type = 1;
    pub const CXIdxObjCContainer_Implementation: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxObjCContainerDeclInfo {
    pub declInfo: *const CXIdxDeclInfo,
    pub kind: CXIdxObjCContainerKind::Type,
}
#[test]
fn bindgen_test_layout_CXIdxObjCContainerDeclInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxObjCContainerDeclInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CXIdxObjCContainerDeclInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxObjCContainerDeclInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxObjCContainerDeclInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCContainerDeclInfo>())).declInfo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCContainerDeclInfo),
            "::",
            stringify!(declInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCContainerDeclInfo>())).kind
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCContainerDeclInfo),
            "::",
            stringify!(kind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxBaseClassInfo {
    pub base: *const CXIdxEntityInfo,
    pub cursor: CXCursor,
    pub loc: CXIdxLoc,
}
#[test]
fn bindgen_test_layout_CXIdxBaseClassInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxBaseClassInfo>(),
        64usize,
        concat!("Size of: ", stringify!(CXIdxBaseClassInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxBaseClassInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxBaseClassInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxBaseClassInfo>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxBaseClassInfo),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxBaseClassInfo>())).cursor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxBaseClassInfo),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxBaseClassInfo>())).loc as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxBaseClassInfo),
            "::",
            stringify!(loc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxObjCProtocolRefInfo {
    pub protocol: *const CXIdxEntityInfo,
    pub cursor: CXCursor,
    pub loc: CXIdxLoc,
}
#[test]
fn bindgen_test_layout_CXIdxObjCProtocolRefInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxObjCProtocolRefInfo>(),
        64usize,
        concat!("Size of: ", stringify!(CXIdxObjCProtocolRefInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxObjCProtocolRefInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxObjCProtocolRefInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCProtocolRefInfo>())).protocol
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCProtocolRefInfo),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCProtocolRefInfo>())).cursor
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCProtocolRefInfo),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCProtocolRefInfo>())).loc as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCProtocolRefInfo),
            "::",
            stringify!(loc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxObjCProtocolRefListInfo {
    pub protocols: *const *const CXIdxObjCProtocolRefInfo,
    pub numProtocols: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXIdxObjCProtocolRefListInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxObjCProtocolRefListInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CXIdxObjCProtocolRefListInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxObjCProtocolRefListInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxObjCProtocolRefListInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCProtocolRefListInfo>())).protocols
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCProtocolRefListInfo),
            "::",
            stringify!(protocols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCProtocolRefListInfo>()))
                .numProtocols as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCProtocolRefListInfo),
            "::",
            stringify!(numProtocols)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxObjCInterfaceDeclInfo {
    pub containerInfo: *const CXIdxObjCContainerDeclInfo,
    pub superInfo: *const CXIdxBaseClassInfo,
    pub protocols: *const CXIdxObjCProtocolRefListInfo,
}
#[test]
fn bindgen_test_layout_CXIdxObjCInterfaceDeclInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxObjCInterfaceDeclInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CXIdxObjCInterfaceDeclInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxObjCInterfaceDeclInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxObjCInterfaceDeclInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCInterfaceDeclInfo>())).containerInfo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCInterfaceDeclInfo),
            "::",
            stringify!(containerInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCInterfaceDeclInfo>())).superInfo
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCInterfaceDeclInfo),
            "::",
            stringify!(superInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCInterfaceDeclInfo>())).protocols
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCInterfaceDeclInfo),
            "::",
            stringify!(protocols)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxObjCCategoryDeclInfo {
    pub containerInfo: *const CXIdxObjCContainerDeclInfo,
    pub objcClass: *const CXIdxEntityInfo,
    pub classCursor: CXCursor,
    pub classLoc: CXIdxLoc,
    pub protocols: *const CXIdxObjCProtocolRefListInfo,
}
#[test]
fn bindgen_test_layout_CXIdxObjCCategoryDeclInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxObjCCategoryDeclInfo>(),
        80usize,
        concat!("Size of: ", stringify!(CXIdxObjCCategoryDeclInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxObjCCategoryDeclInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxObjCCategoryDeclInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCCategoryDeclInfo>())).containerInfo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCCategoryDeclInfo),
            "::",
            stringify!(containerInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCCategoryDeclInfo>())).objcClass
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCCategoryDeclInfo),
            "::",
            stringify!(objcClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCCategoryDeclInfo>())).classCursor
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCCategoryDeclInfo),
            "::",
            stringify!(classCursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCCategoryDeclInfo>())).classLoc
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCCategoryDeclInfo),
            "::",
            stringify!(classLoc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCCategoryDeclInfo>())).protocols
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCCategoryDeclInfo),
            "::",
            stringify!(protocols)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxObjCPropertyDeclInfo {
    pub declInfo: *const CXIdxDeclInfo,
    pub getter: *const CXIdxEntityInfo,
    pub setter: *const CXIdxEntityInfo,
}
#[test]
fn bindgen_test_layout_CXIdxObjCPropertyDeclInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxObjCPropertyDeclInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CXIdxObjCPropertyDeclInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxObjCPropertyDeclInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxObjCPropertyDeclInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCPropertyDeclInfo>())).declInfo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCPropertyDeclInfo),
            "::",
            stringify!(declInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCPropertyDeclInfo>())).getter
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCPropertyDeclInfo),
            "::",
            stringify!(getter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxObjCPropertyDeclInfo>())).setter
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxObjCPropertyDeclInfo),
            "::",
            stringify!(setter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxCXXClassDeclInfo {
    pub declInfo: *const CXIdxDeclInfo,
    pub bases: *const *const CXIdxBaseClassInfo,
    pub numBases: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_CXIdxCXXClassDeclInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxCXXClassDeclInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CXIdxCXXClassDeclInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxCXXClassDeclInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxCXXClassDeclInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxCXXClassDeclInfo>())).declInfo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxCXXClassDeclInfo),
            "::",
            stringify!(declInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxCXXClassDeclInfo>())).bases as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxCXXClassDeclInfo),
            "::",
            stringify!(bases)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxCXXClassDeclInfo>())).numBases
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxCXXClassDeclInfo),
            "::",
            stringify!(numBases)
        )
    );
}
pub mod CXIdxEntityRefKind {
    pub type Type = u32;
    pub const CXIdxEntityRef_Direct: Type = 1;
    pub const CXIdxEntityRef_Implicit: Type = 2;
}
pub mod CXSymbolRole {
    pub type Type = u32;
    pub const CXSymbolRole_None: Type = 0;
    pub const CXSymbolRole_Declaration: Type = 1;
    pub const CXSymbolRole_Definition: Type = 2;
    pub const CXSymbolRole_Reference: Type = 4;
    pub const CXSymbolRole_Read: Type = 8;
    pub const CXSymbolRole_Write: Type = 16;
    pub const CXSymbolRole_Call: Type = 32;
    pub const CXSymbolRole_Dynamic: Type = 64;
    pub const CXSymbolRole_AddressOf: Type = 128;
    pub const CXSymbolRole_Implicit: Type = 256;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXIdxEntityRefInfo {
    pub kind: CXIdxEntityRefKind::Type,
    pub cursor: CXCursor,
    pub loc: CXIdxLoc,
    pub referencedEntity: *const CXIdxEntityInfo,
    pub parentEntity: *const CXIdxEntityInfo,
    pub container: *const CXIdxContainerInfo,
    pub role: CXSymbolRole::Type,
}
#[test]
fn bindgen_test_layout_CXIdxEntityRefInfo() {
    assert_eq!(
        ::std::mem::size_of::<CXIdxEntityRefInfo>(),
        96usize,
        concat!("Size of: ", stringify!(CXIdxEntityRefInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CXIdxEntityRefInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CXIdxEntityRefInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityRefInfo>())).kind as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityRefInfo),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityRefInfo>())).cursor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityRefInfo),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityRefInfo>())).loc as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityRefInfo),
            "::",
            stringify!(loc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityRefInfo>())).referencedEntity
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityRefInfo),
            "::",
            stringify!(referencedEntity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityRefInfo>())).parentEntity
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityRefInfo),
            "::",
            stringify!(parentEntity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityRefInfo>())).container as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityRefInfo),
            "::",
            stringify!(container)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXIdxEntityRefInfo>())).role as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CXIdxEntityRefInfo),
            "::",
            stringify!(role)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexerCallbacks {
    pub abortQuery: ::std::option::Option<
        unsafe extern "C" fn(
            client_data: CXClientData,
            reserved: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub diagnostic: ::std::option::Option<
        unsafe extern "C" fn(
            client_data: CXClientData,
            arg1: CXDiagnosticSet,
            reserved: *mut ::std::os::raw::c_void,
        ),
    >,
    pub enteredMainFile: ::std::option::Option<
        unsafe extern "C" fn(
            client_data: CXClientData,
            mainFile: CXFile,
            reserved: *mut ::std::os::raw::c_void,
        ) -> CXIdxClientFile,
    >,
    pub ppIncludedFile: ::std::option::Option<
        unsafe extern "C" fn(
            client_data: CXClientData,
            arg1: *const CXIdxIncludedFileInfo,
        ) -> CXIdxClientFile,
    >,
    pub importedASTFile: ::std::option::Option<
        unsafe extern "C" fn(
            client_data: CXClientData,
            arg1: *const CXIdxImportedASTFileInfo,
        ) -> CXIdxClientASTFile,
    >,
    pub startedTranslationUnit: ::std::option::Option<
        unsafe extern "C" fn(
            client_data: CXClientData,
            reserved: *mut ::std::os::raw::c_void,
        ) -> CXIdxClientContainer,
    >,
    pub indexDeclaration: ::std::option::Option<
        unsafe extern "C" fn(
            client_data: CXClientData,
            arg1: *const CXIdxDeclInfo,
        ),
    >,
    pub indexEntityReference: ::std::option::Option<
        unsafe extern "C" fn(
            client_data: CXClientData,
            arg1: *const CXIdxEntityRefInfo,
        ),
    >,
}
#[test]
fn bindgen_test_layout_IndexerCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<IndexerCallbacks>(),
        64usize,
        concat!("Size of: ", stringify!(IndexerCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<IndexerCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(IndexerCallbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexerCallbacks>())).abortQuery as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexerCallbacks),
            "::",
            stringify!(abortQuery)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexerCallbacks>())).diagnostic as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexerCallbacks),
            "::",
            stringify!(diagnostic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexerCallbacks>())).enteredMainFile
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexerCallbacks),
            "::",
            stringify!(enteredMainFile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexerCallbacks>())).ppIncludedFile
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexerCallbacks),
            "::",
            stringify!(ppIncludedFile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexerCallbacks>())).importedASTFile
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexerCallbacks),
            "::",
            stringify!(importedASTFile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexerCallbacks>())).startedTranslationUnit
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexerCallbacks),
            "::",
            stringify!(startedTranslationUnit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexerCallbacks>())).indexDeclaration
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexerCallbacks),
            "::",
            stringify!(indexDeclaration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IndexerCallbacks>())).indexEntityReference
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IndexerCallbacks),
            "::",
            stringify!(indexEntityReference)
        )
    );
}
extern "C" {
    pub fn clang_index_isEntityObjCContainerKind(
        arg1: CXIdxEntityKind::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_index_getObjCContainerDeclInfo(
        arg1: *const CXIdxDeclInfo,
    ) -> *const CXIdxObjCContainerDeclInfo;
}
extern "C" {
    pub fn clang_index_getObjCInterfaceDeclInfo(
        arg1: *const CXIdxDeclInfo,
    ) -> *const CXIdxObjCInterfaceDeclInfo;
}
extern "C" {
    pub fn clang_index_getObjCCategoryDeclInfo(
        arg1: *const CXIdxDeclInfo,
    ) -> *const CXIdxObjCCategoryDeclInfo;
}
extern "C" {
    pub fn clang_index_getObjCProtocolRefListInfo(
        arg1: *const CXIdxDeclInfo,
    ) -> *const CXIdxObjCProtocolRefListInfo;
}
extern "C" {
    pub fn clang_index_getObjCPropertyDeclInfo(
        arg1: *const CXIdxDeclInfo,
    ) -> *const CXIdxObjCPropertyDeclInfo;
}
extern "C" {
    pub fn clang_index_getIBOutletCollectionAttrInfo(
        arg1: *const CXIdxAttrInfo,
    ) -> *const CXIdxIBOutletCollectionAttrInfo;
}
extern "C" {
    pub fn clang_index_getCXXClassDeclInfo(
        arg1: *const CXIdxDeclInfo,
    ) -> *const CXIdxCXXClassDeclInfo;
}
extern "C" {
    pub fn clang_index_getClientContainer(
        arg1: *const CXIdxContainerInfo,
    ) -> CXIdxClientContainer;
}
extern "C" {
    pub fn clang_index_setClientContainer(
        arg1: *const CXIdxContainerInfo,
        arg2: CXIdxClientContainer,
    );
}
extern "C" {
    pub fn clang_index_getClientEntity(
        arg1: *const CXIdxEntityInfo,
    ) -> CXIdxClientEntity;
}
extern "C" {
    pub fn clang_index_setClientEntity(
        arg1: *const CXIdxEntityInfo,
        arg2: CXIdxClientEntity,
    );
}
pub type CXIndexAction = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn clang_IndexAction_create(CIdx: CXIndex) -> CXIndexAction;
}
extern "C" {
    pub fn clang_IndexAction_dispose(arg1: CXIndexAction);
}
pub mod CXIndexOptFlags {
    pub type Type = u32;
    pub const CXIndexOpt_None: Type = 0;
    pub const CXIndexOpt_SuppressRedundantRefs: Type = 1;
    pub const CXIndexOpt_IndexFunctionLocalSymbols: Type = 2;
    pub const CXIndexOpt_IndexImplicitTemplateInstantiations: Type = 4;
    pub const CXIndexOpt_SuppressWarnings: Type = 8;
    pub const CXIndexOpt_SkipParsedBodiesInSession: Type = 16;
}
extern "C" {
    pub fn clang_indexSourceFile(
        arg1: CXIndexAction,
        client_data: CXClientData,
        index_callbacks: *mut IndexerCallbacks,
        index_callbacks_size: ::std::os::raw::c_uint,
        index_options: ::std::os::raw::c_uint,
        source_filename: *const ::std::os::raw::c_char,
        command_line_args: *const *const ::std::os::raw::c_char,
        num_command_line_args: ::std::os::raw::c_int,
        unsaved_files: *mut CXUnsavedFile,
        num_unsaved_files: ::std::os::raw::c_uint,
        out_TU: *mut CXTranslationUnit,
        TU_options: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_indexSourceFileFullArgv(
        arg1: CXIndexAction,
        client_data: CXClientData,
        index_callbacks: *mut IndexerCallbacks,
        index_callbacks_size: ::std::os::raw::c_uint,
        index_options: ::std::os::raw::c_uint,
        source_filename: *const ::std::os::raw::c_char,
        command_line_args: *const *const ::std::os::raw::c_char,
        num_command_line_args: ::std::os::raw::c_int,
        unsaved_files: *mut CXUnsavedFile,
        num_unsaved_files: ::std::os::raw::c_uint,
        out_TU: *mut CXTranslationUnit,
        TU_options: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_indexTranslationUnit(
        arg1: CXIndexAction,
        client_data: CXClientData,
        index_callbacks: *mut IndexerCallbacks,
        index_callbacks_size: ::std::os::raw::c_uint,
        index_options: ::std::os::raw::c_uint,
        arg2: CXTranslationUnit,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clang_indexLoc_getFileLocation(
        loc: CXIdxLoc,
        indexFile: *mut CXIdxClientFile,
        file: *mut CXFile,
        line: *mut ::std::os::raw::c_uint,
        column: *mut ::std::os::raw::c_uint,
        offset: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn clang_indexLoc_getCXSourceLocation(
        loc: CXIdxLoc,
    ) -> CXSourceLocation;
}
pub type CXFieldVisitor = ::std::option::Option<
    unsafe extern "C" fn(
        C: CXCursor,
        client_data: CXClientData,
    ) -> CXVisitorResult::Type,
>;
extern "C" {
    pub fn clang_Type_visitFields(
        T: CXType,
        visitor: CXFieldVisitor,
        client_data: CXClientData,
    ) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXComment {
    pub ASTNode: *const ::std::os::raw::c_void,
    pub TranslationUnit: CXTranslationUnit,
}
#[test]
fn bindgen_test_layout_CXComment() {
    assert_eq!(
        ::std::mem::size_of::<CXComment>(),
        16usize,
        concat!("Size of: ", stringify!(CXComment))
    );
    assert_eq!(
        ::std::mem::align_of::<CXComment>(),
        8usize,
        concat!("Alignment of ", stringify!(CXComment))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXComment>())).ASTNode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXComment),
            "::",
            stringify!(ASTNode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CXComment>())).TranslationUnit as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXComment),
            "::",
            stringify!(TranslationUnit)
        )
    );
}
extern "C" {
    pub fn clang_Cursor_getParsedComment(C: CXCursor) -> CXComment;
}
pub mod CXCommentKind {
    pub type Type = u32;
    pub const CXComment_Null: Type = 0;
    pub const CXComment_Text: Type = 1;
    pub const CXComment_InlineCommand: Type = 2;
    pub const CXComment_HTMLStartTag: Type = 3;
    pub const CXComment_HTMLEndTag: Type = 4;
    pub const CXComment_Paragraph: Type = 5;
    pub const CXComment_BlockCommand: Type = 6;
    pub const CXComment_ParamCommand: Type = 7;
    pub const CXComment_TParamCommand: Type = 8;
    pub const CXComment_VerbatimBlockCommand: Type = 9;
    pub const CXComment_VerbatimBlockLine: Type = 10;
    pub const CXComment_VerbatimLine: Type = 11;
    pub const CXComment_FullComment: Type = 12;
}
pub mod CXCommentInlineCommandRenderKind {
    pub type Type = u32;
    pub const CXCommentInlineCommandRenderKind_Normal: Type = 0;
    pub const CXCommentInlineCommandRenderKind_Bold: Type = 1;
    pub const CXCommentInlineCommandRenderKind_Monospaced: Type = 2;
    pub const CXCommentInlineCommandRenderKind_Emphasized: Type = 3;
}
pub mod CXCommentParamPassDirection {
    pub type Type = u32;
    pub const CXCommentParamPassDirection_In: Type = 0;
    pub const CXCommentParamPassDirection_Out: Type = 1;
    pub const CXCommentParamPassDirection_InOut: Type = 2;
}
extern "C" {
    pub fn clang_Comment_getKind(Comment: CXComment) -> CXCommentKind::Type;
}
extern "C" {
    pub fn clang_Comment_getNumChildren(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_Comment_getChild(
        Comment: CXComment,
        ChildIdx: ::std::os::raw::c_uint,
    ) -> CXComment;
}
extern "C" {
    pub fn clang_Comment_isWhitespace(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_InlineContentComment_hasTrailingNewline(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_TextComment_getText(Comment: CXComment) -> CXString;
}
extern "C" {
    pub fn clang_InlineCommandComment_getCommandName(
        Comment: CXComment,
    ) -> CXString;
}
extern "C" {
    pub fn clang_InlineCommandComment_getRenderKind(
        Comment: CXComment,
    ) -> CXCommentInlineCommandRenderKind::Type;
}
extern "C" {
    pub fn clang_InlineCommandComment_getNumArgs(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_InlineCommandComment_getArgText(
        Comment: CXComment,
        ArgIdx: ::std::os::raw::c_uint,
    ) -> CXString;
}
extern "C" {
    pub fn clang_HTMLTagComment_getTagName(Comment: CXComment) -> CXString;
}
extern "C" {
    pub fn clang_HTMLStartTagComment_isSelfClosing(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_HTMLStartTag_getNumAttrs(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_HTMLStartTag_getAttrName(
        Comment: CXComment,
        AttrIdx: ::std::os::raw::c_uint,
    ) -> CXString;
}
extern "C" {
    pub fn clang_HTMLStartTag_getAttrValue(
        Comment: CXComment,
        AttrIdx: ::std::os::raw::c_uint,
    ) -> CXString;
}
extern "C" {
    pub fn clang_BlockCommandComment_getCommandName(
        Comment: CXComment,
    ) -> CXString;
}
extern "C" {
    pub fn clang_BlockCommandComment_getNumArgs(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_BlockCommandComment_getArgText(
        Comment: CXComment,
        ArgIdx: ::std::os::raw::c_uint,
    ) -> CXString;
}
extern "C" {
    pub fn clang_BlockCommandComment_getParagraph(
        Comment: CXComment,
    ) -> CXComment;
}
extern "C" {
    pub fn clang_ParamCommandComment_getParamName(
        Comment: CXComment,
    ) -> CXString;
}
extern "C" {
    pub fn clang_ParamCommandComment_isParamIndexValid(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_ParamCommandComment_getParamIndex(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_ParamCommandComment_isDirectionExplicit(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_ParamCommandComment_getDirection(
        Comment: CXComment,
    ) -> CXCommentParamPassDirection::Type;
}
extern "C" {
    pub fn clang_TParamCommandComment_getParamName(
        Comment: CXComment,
    ) -> CXString;
}
extern "C" {
    pub fn clang_TParamCommandComment_isParamPositionValid(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_TParamCommandComment_getDepth(
        Comment: CXComment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_TParamCommandComment_getIndex(
        Comment: CXComment,
        Depth: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn clang_VerbatimBlockLineComment_getText(
        Comment: CXComment,
    ) -> CXString;
}
extern "C" {
    pub fn clang_VerbatimLineComment_getText(Comment: CXComment) -> CXString;
}
extern "C" {
    pub fn clang_HTMLTagComment_getAsString(Comment: CXComment) -> CXString;
}
extern "C" {
    pub fn clang_FullComment_getAsHTML(Comment: CXComment) -> CXString;
}
extern "C" {
    pub fn clang_FullComment_getAsXML(Comment: CXComment) -> CXString;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_ASTUnit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_TargetInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_CompoundStmt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_Decl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_Diagnostic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_StoredDiagnostic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_TranslationUnitDecl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_Expr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_Type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_FileEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_SourceLocation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_CXXBaseSpecifier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_ASTContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_SourceRange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_Attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_PreprocessedEntity {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_comments_Comment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clang_comments_FullComment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EvalResult {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct BindgenStringRef {
    pub s: *mut ::std::os::raw::c_char,
    pub len: size_t,
}
#[test]
fn bindgen_test_layout_BindgenStringRef() {
    assert_eq!(
        ::std::mem::size_of::<BindgenStringRef>(),
        16usize,
        concat!("Size of: ", stringify!(BindgenStringRef))
    );
    assert_eq!(
        ::std::mem::align_of::<BindgenStringRef>(),
        8usize,
        concat!("Alignment of ", stringify!(BindgenStringRef))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BindgenStringRef>())).s as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BindgenStringRef),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BindgenStringRef>())).len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BindgenStringRef),
            "::",
            stringify!(len)
        )
    );
}
pub type BindgenQualType = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug)]
pub struct BindgenStringRefSet {
    pub strings: *mut BindgenStringRef,
    pub len: size_t,
}
#[test]
fn bindgen_test_layout_BindgenStringRefSet() {
    assert_eq!(
        ::std::mem::size_of::<BindgenStringRefSet>(),
        16usize,
        concat!("Size of: ", stringify!(BindgenStringRefSet))
    );
    assert_eq!(
        ::std::mem::align_of::<BindgenStringRefSet>(),
        8usize,
        concat!("Alignment of ", stringify!(BindgenStringRefSet))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BindgenStringRefSet>())).strings as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BindgenStringRefSet),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BindgenStringRefSet>())).len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BindgenStringRefSet),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct BindgenSourceRange {
    pub B: *mut clang_SourceLocation,
    pub E: *mut clang_SourceLocation,
}
#[test]
fn bindgen_test_layout_BindgenSourceRange() {
    assert_eq!(
        ::std::mem::size_of::<BindgenSourceRange>(),
        16usize,
        concat!("Size of: ", stringify!(BindgenSourceRange))
    );
    assert_eq!(
        ::std::mem::align_of::<BindgenSourceRange>(),
        8usize,
        concat!("Alignment of ", stringify!(BindgenSourceRange))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BindgenSourceRange>())).B as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BindgenSourceRange),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BindgenSourceRange>())).E as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BindgenSourceRange),
            "::",
            stringify!(E)
        )
    );
}
extern "C" {
    pub fn deleteString(s: *mut BindgenStringRef);
}
extern "C" {
    pub fn cString(s: *mut BindgenStringRef) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn deleteStringSet(s: *mut BindgenStringRefSet);
}
extern "C" {
    pub fn deleteSourceLocation(s: *mut clang_SourceLocation);
}
extern "C" {
    pub fn deleteSourceRange(s: *mut BindgenSourceRange);
}
extern "C" {
    pub fn deleteEvalResult(e: *mut EvalResult);
}
extern "C" {
    pub fn ASTUnit_getContext(
        arg1: *mut clang_ASTUnit,
    ) -> *mut clang_ASTContext;
}
extern "C" {
    pub fn parseTranslationUnit(
        source_filename: *const ::std::os::raw::c_char,
        command_line_args: *const *const ::std::os::raw::c_char,
        num_command_line_args: ::std::os::raw::c_int,
        options: ::std::os::raw::c_uint,
        unsaved_files: *mut CXUnsavedFile,
        num_unsaved_files: ::std::os::raw::c_uint,
    ) -> *mut clang_ASTUnit;
}
extern "C" {
    pub fn disposeASTUnit(AU: *mut clang_ASTUnit);
}
extern "C" {
    pub fn ASTUnit_getNumDiagnostics(
        AU: *const clang_ASTUnit,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ASTUnit_getDiagnostic(
        AU: *const clang_ASTUnit,
        i: ::std::os::raw::c_uint,
    ) -> *const clang_StoredDiagnostic;
}
extern "C" {
    pub fn ASTUnit_getTargetInfo(
        AU: *mut clang_ASTUnit,
    ) -> *const clang_TargetInfo;
}
extern "C" {
    pub fn TargetInfo_getPointerWidth(
        TI: *const clang_TargetInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TargetInfo_getTriple(
        TI: *const clang_TargetInfo,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn Expr_Evaluate(
        E: *const clang_Expr,
        Ctx: *mut clang_ASTContext,
    ) -> *mut EvalResult;
}
extern "C" {
    pub fn Decl_Evaluate(
        D: *const clang_Decl,
        Ctx: *mut clang_ASTContext,
    ) -> *mut EvalResult;
}
extern "C" {
    pub fn EvalResult_getKind(arg1: *mut EvalResult) -> CXEvalResultKind::Type;
}
extern "C" {
    pub fn EvalResult_getAsDouble(arg1: *mut EvalResult) -> f64;
}
extern "C" {
    pub fn EvalResult_isUnsignedInt(arg1: *mut EvalResult) -> bool;
}
extern "C" {
    pub fn EvalResult_getAsUnsigned(
        arg1: *mut EvalResult,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn EvalResult_getAsLongLong(
        arg1: *mut EvalResult,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn EvalResult_getAsStr(arg1: *mut EvalResult) -> BindgenStringRef;
}
extern "C" {
    pub fn Diagnostic_format(
        arg1: *const clang_StoredDiagnostic,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn Diagnostic_getSeverity(
        arg1: *const clang_StoredDiagnostic,
    ) -> CXDiagnosticSeverity::Type;
}
extern "C" {
    pub fn getTranslationUnitDecl(
        arg1: *mut clang_ASTUnit,
    ) -> *const clang_Decl;
}
extern "C" {
    pub fn CursorKind_isInvalid(kind: CXCursorKind::Type) -> bool;
}
extern "C" {
    pub fn Decl_getLexicalParent(D: *const clang_Decl) -> *const clang_Decl;
}
extern "C" {
    pub fn Decl_getSemanticParent(D: *const clang_Decl) -> *const clang_Decl;
}
extern "C" {
    pub fn Decl_getDefinition(
        D: *const clang_Decl,
        isReference: bool,
    ) -> *const clang_Decl;
}
extern "C" {
    pub fn Decl_getReferenced(D: *const clang_Decl) -> *const clang_Decl;
}
extern "C" {
    pub fn Decl_getCanonical(D: *const clang_Decl) -> *const clang_Decl;
}
extern "C" {
    pub fn Decl_getSpecializedTemplate(
        D: *const clang_Decl,
    ) -> *const clang_Decl;
}
extern "C" {
    pub fn Decl_getTemplateCursorKind(
        D: *const clang_Decl,
    ) -> CXCursorKind::Type;
}
extern "C" {
    pub fn Decl_getArgument(
        D: *const clang_Decl,
        i: ::std::os::raw::c_uint,
    ) -> *const clang_Decl;
}
extern "C" {
    pub fn Decl_getNumArguments(D: *const clang_Decl) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Decl_getUSR(D: *const clang_Decl) -> BindgenStringRef;
}
extern "C" {
    pub fn Decl_getSpelling(D: *const clang_Decl) -> BindgenStringRef;
}
extern "C" {
    pub fn Decl_getDisplayName(D: *const clang_Decl) -> BindgenStringRef;
}
extern "C" {
    pub fn Decl_getMangling(
        D: *const clang_Decl,
        arg1: *mut clang_ASTContext,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn Decl_getCXXManglings(
        D: *const clang_Decl,
        arg1: *mut clang_ASTContext,
    ) -> BindgenStringRefSet;
}
extern "C" {
    pub fn Decl_getNumTemplateArguments(
        D: *const clang_Decl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Decl_getCXCursorKind(D: *const clang_Decl) -> CXCursorKind::Type;
}
extern "C" {
    pub fn Decl_isDefinition(D: *const clang_Decl) -> bool;
}
extern "C" {
    pub fn Decl_getLocation(D: *const clang_Decl) -> *mut clang_SourceLocation;
}
extern "C" {
    pub fn Decl_getRawCommentText(
        D: *const clang_Decl,
        arg1: *mut clang_ASTContext,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn Decl_getParsedComment(
        D: *const clang_Decl,
        arg1: *mut clang_ASTContext,
    ) -> *mut clang_comments_Comment;
}
extern "C" {
    pub fn Decl_getType(
        D: *const clang_Decl,
        arg1: *mut clang_ASTContext,
    ) -> BindgenQualType;
}
extern "C" {
    pub fn Decl_isFunctionInlined(D: *const clang_Decl) -> bool;
}
extern "C" {
    pub fn Decl_getFieldDeclBitWidth(
        D: *const clang_Decl,
        arg1: *mut clang_ASTContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Decl_getEnumDeclIntegerType(D: *const clang_Decl)
        -> BindgenQualType;
}
extern "C" {
    pub fn Decl_getEnumConstantValue(D: *const clang_Decl) -> i64;
}
extern "C" {
    pub fn Decl_getEnumConstantUnsignedValue(D: *const clang_Decl) -> u64;
}
extern "C" {
    pub fn Decl_getOffsetOfField(
        D: *const clang_Decl,
        arg1: *mut clang_ASTContext,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn Decl_getSourceRange(D: *const clang_Decl) -> BindgenSourceRange;
}
extern "C" {
    pub fn Decl_getTypedefDeclUnderlyingType(
        D: *const clang_Decl,
    ) -> BindgenQualType;
}
extern "C" {
    pub fn Decl_getLinkage(D: *const clang_Decl) -> CXLinkageKind::Type;
}
extern "C" {
    pub fn Decl_getVisibility(D: *const clang_Decl) -> CXVisibilityKind::Type;
}
extern "C" {
    pub fn Decl_getAccess(D: *const clang_Decl) -> CX_CXXAccessSpecifier::Type;
}
extern "C" {
    pub fn CXXField_isMutable(D: *const clang_Decl) -> bool;
}
extern "C" {
    pub fn CXXMethod_isStatic(D: *const clang_Decl) -> bool;
}
extern "C" {
    pub fn CXXMethod_isConst(D: *const clang_Decl) -> bool;
}
extern "C" {
    pub fn CXXMethod_isVirtual(D: *const clang_Decl) -> bool;
}
extern "C" {
    pub fn CXXMethod_isPureVirtual(D: *const clang_Decl) -> bool;
}
extern "C" {
    pub fn Decl_getResultType(
        D: *const clang_Decl,
        arg1: *mut clang_ASTContext,
    ) -> BindgenQualType;
}
extern "C" {
    pub fn Expr_getArgument(
        E: *const clang_Expr,
        i: ::std::os::raw::c_uint,
    ) -> *const clang_Expr;
}
extern "C" {
    pub fn Expr_getNumArguments(E: *const clang_Expr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Expr_getUSR(E: *const clang_Expr) -> BindgenStringRef;
}
extern "C" {
    pub fn Expr_getSpelling(E: *const clang_Expr) -> BindgenStringRef;
}
extern "C" {
    pub fn Expr_getDisplayName(E: *const clang_Expr) -> BindgenStringRef;
}
extern "C" {
    pub fn Expr_getMangling(E: *const clang_Expr) -> BindgenStringRef;
}
extern "C" {
    pub fn Expr_getCXXManglings(E: *const clang_Expr) -> BindgenStringRefSet;
}
extern "C" {
    pub fn Expr_getCXCursorKind(E: *const clang_Expr) -> CXCursorKind::Type;
}
extern "C" {
    pub fn Expr_getLocation(E: *const clang_Expr) -> *mut clang_SourceLocation;
}
extern "C" {
    pub fn Expr_getRawCommentText(E: *const clang_Expr) -> BindgenStringRef;
}
extern "C" {
    pub fn Expr_getParsedComment(
        E: *const clang_Expr,
    ) -> *mut clang_comments_FullComment;
}
extern "C" {
    pub fn Expr_getType(E: *const clang_Expr) -> BindgenQualType;
}
extern "C" {
    pub fn Expr_getSourceRange(E: *const clang_Expr) -> BindgenSourceRange;
}
extern "C" {
    pub fn Type_getDeclaration(arg1: BindgenQualType) -> *const clang_Decl;
}
extern "C" {
    pub fn Attr_getCXCursorKind(arg1: *const clang_Attr) -> CXCursorKind::Type;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Node {
    pub kind: CXCursorKind::Type,
    pub ptr: Node__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Node__bindgen_ty_1 {
    pub decl: *const clang_Decl,
    pub expr: *const clang_Expr,
    pub base: *const clang_CXXBaseSpecifier,
    pub attr: *const clang_Attr,
    pub ppe: *const clang_PreprocessedEntity,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Node__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Node__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Node__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Node__bindgen_ty_1>())).decl as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Node__bindgen_ty_1),
            "::",
            stringify!(decl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Node__bindgen_ty_1>())).expr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Node__bindgen_ty_1),
            "::",
            stringify!(expr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Node__bindgen_ty_1>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Node__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Node__bindgen_ty_1>())).attr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Node__bindgen_ty_1),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Node__bindgen_ty_1>())).ppe as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Node__bindgen_ty_1),
            "::",
            stringify!(ppe)
        )
    );
}
#[test]
fn bindgen_test_layout_Node() {
    assert_eq!(
        ::std::mem::size_of::<Node>(),
        16usize,
        concat!("Size of: ", stringify!(Node))
    );
    assert_eq!(
        ::std::mem::align_of::<Node>(),
        8usize,
        concat!("Alignment of ", stringify!(Node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Node>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Node),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Node>())).ptr as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Node), "::", stringify!(ptr))
    );
}
pub type Visitor = ::std::option::Option<
    unsafe extern "C" fn(
        N: Node,
        parent: Node,
        unit: *mut clang_ASTUnit,
        client_data: CXClientData,
    ) -> CXChildVisitResult::Type,
>;
extern "C" {
    pub fn Decl_visitChildren(
        Parent: *const clang_Decl,
        kind: CXCursorKind::Type,
        V: Visitor,
        Unit: *mut clang_ASTUnit,
        data: CXClientData,
    );
}
extern "C" {
    pub fn Expr_visitChildren(
        Parent: *const clang_Expr,
        kind: CXCursorKind::Type,
        V: Visitor,
        Unit: *mut clang_ASTUnit,
        data: CXClientData,
    );
}
extern "C" {
    pub fn CXXBaseSpecifier_visitChildren(
        Parent: *const clang_CXXBaseSpecifier,
        kind: CXCursorKind::Type,
        V: Visitor,
        Unit: *mut clang_ASTUnit,
        data: CXClientData,
    );
}
extern "C" {
    pub fn tokenize(
        TU: *mut clang_ASTUnit,
        Range: BindgenSourceRange,
        Tokens: *mut *mut CXToken,
        NumTokens: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn disposeTokens(
        TU: *const clang_ASTUnit,
        Tokens: *mut CXToken,
        NumTokens: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn getTokenKind(token: CXToken) -> CXTokenKind::Type;
}
extern "C" {
    pub fn getTokenSpelling(
        TU: *mut clang_ASTUnit,
        token: CXToken,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn Type_kind(
        arg1: BindgenQualType,
        arg2: *mut clang_ASTContext,
    ) -> CXTypeKind::Type;
}
extern "C" {
    pub fn Type_getTypeSpelling(
        arg1: BindgenQualType,
        arg2: *mut clang_ASTContext,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn Type_isConstQualifiedType(arg1: BindgenQualType) -> bool;
}
extern "C" {
    pub fn Type_getSizeOf(
        arg1: BindgenQualType,
        arg2: *mut clang_ASTContext,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn Type_getAlignOf(
        arg1: BindgenQualType,
        arg2: *mut clang_ASTContext,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn Type_getNumTemplateArguments(
        arg1: BindgenQualType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Type_getArgType(
        T: BindgenQualType,
        index: ::std::os::raw::c_uint,
    ) -> BindgenQualType;
}
extern "C" {
    pub fn Type_getNumArgTypes(arg1: BindgenQualType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Type_getPointeeType(arg1: BindgenQualType) -> BindgenQualType;
}
extern "C" {
    pub fn Type_getElementType(arg1: BindgenQualType) -> BindgenQualType;
}
extern "C" {
    pub fn Type_getNumElements(arg1: BindgenQualType) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Type_getCanonicalType(
        arg1: BindgenQualType,
        arg2: *mut clang_ASTContext,
    ) -> BindgenQualType;
}
extern "C" {
    pub fn Type_isFunctionTypeVariadic(arg1: BindgenQualType) -> bool;
}
extern "C" {
    pub fn Type_getResultType(arg1: BindgenQualType) -> BindgenQualType;
}
extern "C" {
    pub fn Type_getFunctionTypeCallingConv(
        arg1: BindgenQualType,
    ) -> CXCallingConv::Type;
}
extern "C" {
    pub fn Type_getNamedType(arg1: BindgenQualType) -> BindgenQualType;
}
extern "C" {
    pub fn Type_getTemplateArgumentAsType(
        T: BindgenQualType,
        index: ::std::os::raw::c_uint,
    ) -> BindgenQualType;
}
extern "C" {
    pub fn getSpellingLocation(
        AST: *mut clang_ASTUnit,
        T: *const clang_SourceLocation,
        file: *mut *mut clang_FileEntry,
        line: *mut ::std::os::raw::c_int,
        col: *mut ::std::os::raw::c_int,
        off: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Comment_getKind(
        arg1: *const clang_comments_Comment,
    ) -> CXCommentKind::Type;
}
extern "C" {
    pub fn Comment_getNumChildren(
        arg1: *const clang_comments_Comment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Comment_getChild(
        arg1: *const clang_comments_Comment,
        index: ::std::os::raw::c_uint,
    ) -> *mut clang_comments_Comment;
}
extern "C" {
    pub fn HTMLTagComment_getTagName(
        arg1: *const clang_comments_Comment,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn HTMLStartTag_getNumAttrs(
        arg1: *const clang_comments_Comment,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn HTMLStartTag_getAttrName(
        arg1: *const clang_comments_Comment,
        arg2: ::std::os::raw::c_uint,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn HTMLStartTag_getAttrValue(
        arg1: *const clang_comments_Comment,
        arg2: ::std::os::raw::c_uint,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn CursorKind_getSpelling(arg1: CXCursorKind::Type)
        -> BindgenStringRef;
}
extern "C" {
    pub fn TypeKind_getSpelling(arg1: CXTypeKind::Type) -> BindgenStringRef;
}
extern "C" {
    pub fn PreprocessedEntity_getSpelling(
        arg1: *const clang_PreprocessedEntity,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn FileEntry_getName(arg1: *const clang_FileEntry) -> BindgenStringRef;
}
extern "C" {
    pub fn getClangVersion() -> BindgenStringRef;
}
extern "C" {
    pub fn CXXBaseSpecifier_isVirtualBase(
        arg1: *const clang_CXXBaseSpecifier,
    ) -> bool;
}
extern "C" {
    pub fn CXXBaseSpecifier_getType(
        arg1: *const clang_CXXBaseSpecifier,
    ) -> BindgenQualType;
}
extern "C" {
    pub fn CXXBaseSpecifier_getSpelling(
        arg1: *const clang_CXXBaseSpecifier,
    ) -> BindgenStringRef;
}
extern "C" {
    pub fn CXXBaseSpecifier_getLocation(
        arg1: *const clang_CXXBaseSpecifier,
    ) -> *mut clang_SourceLocation;
}
extern "C" {
    pub fn Attr_getLocation(
        arg1: *const clang_Attr,
    ) -> *mut clang_SourceLocation;
}
extern "C" {
    pub fn PreprocessedEntity_getLocation(
        arg1: *const clang_PreprocessedEntity,
    ) -> *mut clang_SourceLocation;
}
extern "C" {
    pub fn PreprocessedEntity_getIncludedFile(
        arg1: *const clang_PreprocessedEntity,
    ) -> *const clang_FileEntry;
}
extern "C" {
    pub fn CXXBaseSpecifier_getSourceRange(
        arg1: *const clang_CXXBaseSpecifier,
    ) -> BindgenSourceRange;
}
extern "C" {
    pub fn CXXBaseSpecifier_getAccess(
        arg1: *const clang_CXXBaseSpecifier,
    ) -> CX_CXXAccessSpecifier::Type;
}
extern "C" {
    pub fn Attr_getSourceRange(arg1: *const clang_Attr) -> BindgenSourceRange;
}
extern "C" {
    pub fn PreprocessedEntity_getSourceRange(
        arg1: *const clang_PreprocessedEntity,
    ) -> BindgenSourceRange;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
