/* automatically generated by rust-bindgen */


#![allow(non_snake_case)]


#[repr(C)]
#[derive(Debug)]
pub struct Foo<T, U> {
    pub m_member: T,
    pub m_member_ptr: *mut T,
    pub m_member_arr: [T; 1usize],
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
extern "C" {
    #[link_name = "_Z3bar3FooIiiE"]
    pub fn bar(foo: Foo<::std::os::raw::c_int, ::std::os::raw::c_int>);
}
#[repr(C)]
#[derive(Debug)]
pub struct D<T> {
    pub m_foo: D_MyFoo,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
pub type D_MyFoo = Foo<::std::os::raw::c_int, ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug)]
pub struct D_U<T, Z> {
    pub m_nested_foo: D_MyFoo,
    pub m_baz: Z,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rooted<T> {
    pub prev: *mut T,
    pub next: *mut Rooted<*mut ::std::os::raw::c_void>,
    pub ptr: T,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RootedContainer {
    pub root: Rooted<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_RootedContainer() {
    assert_eq!(::std::mem::size_of::<RootedContainer>() , 24usize);
    assert_eq!(::std::mem::align_of::<RootedContainer>() , 8usize);
}
impl Clone for RootedContainer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug)]
pub struct WithDtor<T> {
    pub member: T,
}
pub type WithDtorIntFwd = WithDtor<::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug)]
pub struct PODButContainsDtor {
    pub member: WithDtorIntFwd,
}
#[test]
fn bindgen_test_layout_PODButContainsDtor() {
    assert_eq!(::std::mem::size_of::<PODButContainsDtor>() , 4usize);
    assert_eq!(::std::mem::align_of::<PODButContainsDtor>() , 4usize);
}
/** <div rustbindgen opaque> */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Opaque<T> {
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct POD {
    pub opaque_member: u32,
}
#[test]
fn bindgen_test_layout_POD() {
    assert_eq!(::std::mem::size_of::<POD>() , 4usize);
    assert_eq!(::std::mem::align_of::<POD>() , 4usize);
}
impl Clone for POD {
    fn clone(&self) -> Self { *self }
}
/**
 * <div rustbindgen replaces="NestedReplaced"></div>
 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestedReplaced<T> {
    pub buff: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestedBase<T, U> {
    pub buff: *mut T,
    pub _phantom_1: ::std::marker::PhantomData<U>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Incomplete<T> {
    pub d: T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestedContainer<T> {
    pub c: T,
    pub nested: NestedReplaced<T>,
    pub inc: Incomplete<T>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Untemplated {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_Untemplated() {
    assert_eq!(::std::mem::size_of::<Untemplated>() , 1usize);
    assert_eq!(::std::mem::align_of::<Untemplated>() , 1usize);
}
impl Clone for Untemplated {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Templated<T> {
    pub m_untemplated: Untemplated,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
/**
 * If the replacement doesn't happen at the parse level the container would be
 * copy and the replacement wouldn't, so this wouldn't compile.
 *
 * <div rustbindgen replaces="ReplacedWithoutDestructor"></div>
 */
#[repr(C)]
#[derive(Debug)]
pub struct ReplacedWithoutDestructor<T> {
    pub buff: *mut T,
}
#[repr(C)]
#[derive(Debug)]
pub struct ShouldNotBeCopiable<T> {
    pub m_member: ReplacedWithoutDestructor<T>,
}
#[repr(C)]
#[derive(Debug)]
pub struct ShouldNotBeCopiableAsWell<U> {
    pub m_member: ReplacedWithoutDestructorFwd<U>,
}
/**
 * If the replacement doesn't happen at the parse level the container would be
 * copy and the replacement wouldn't, so this wouldn't compile.
 *
 * <div rustbindgen replaces="ReplacedWithoutDestructorFwd"></div>
 */
#[repr(C)]
#[derive(Debug)]
pub struct ReplacedWithoutDestructorFwd<T> {
    pub buff: *mut T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TemplateWithVar<T> {
    pub _address: u8,
    pub _phantom_0: ::std::marker::PhantomData<T>,
}
